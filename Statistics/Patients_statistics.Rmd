---
title: "Statistical Analysis"
author: "Elena Marochkina"
date: "`r Sys.Date()`"
output: 
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  echo = FALSE,
  message = FALSE
)

```

```{r libraries, set colors}
library(tidyverse)
library(readr)
library(dplyr)
library(tidyr)
library(flextable)
library(officer)
library(RColorBrewer)
library(broom)
library(tibble)
library(nortest)
library(survival)
library(survminer)
library(ggpubr)
library(lme4)   
library(lmerTest) 
library(glmnet)
library(pROC)
library(corrplot)
library(gridExtra)
library(knitr)
library(kableExtra)


# Custom theme for visualisations
theme_custom <- theme_minimal() +
  theme (
    plot.title = element_text(size = 14, hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    strip.text = element_text(size = 10),
    axis.text = element_text(size = 8),
    axis.title = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
  )

# Palette for visualisations
color_palette <- c(brewer.pal(9, "Pastel1"), brewer.pal(8, "Pastel2"), brewer.pal(8, "Set3"))

```

```{r Descriptive Stat functions}
# Function to calculate 95% confidence interval for the mean
ci_95 <- function(x) {
  n <- sum(!is.na(x))
  if (n < 3) return("Н/П*")
  se <- sd(x, na.rm = TRUE) / sqrt(n)  # Standard Error
  mean_x <- mean(x, na.rm = TRUE)
  ci <- c(mean_x - 1.96 * se, mean_x + 1.96 * se)
  paste0(round(ci[1], 2), " - ", round(ci[2], 2))
}

# List of descriptive statistics
statistics <- list(
  `_Number of values` = ~as.character(sum(!is.na(.x))),
  `_No data` = ~as.character(sum(is.na(.x))),
  `_Mean` = ~ifelse(sum(!is.na(.x)) == 0, "NA", as.character(mean(.x, na.rm = TRUE) %>% round(2))),
  `_Median` = ~ifelse(sum(!is.na(.x)) == 0, "NA", as.character(median(.x, na.rm = TRUE) %>% round(2))),
  `_SD` = ~ifelse(sum(!is.na(.x)) < 3, "NA", as.character(sd(.x, na.rm = TRUE) %>% round(2))),
  `_Q1 - Q3` = ~ifelse(sum(!is.na(.x)) == 0, "NA", paste0(as.character(quantile(.x, 0.25, na.rm = TRUE) %>% round(2)), " - ", as.character(quantile(.x, 0.75, na.rm = TRUE) %>% round(2)))),
  `_IQR` = ~ifelse(sum(!is.na(.x)) == 0, "NA", as.character(IQR(.x, na.rm = TRUE) %>% round(2))),
  `_95% CI` = ~ci_95(.x),
  `_min` = ~ifelse(sum(!is.na(.x)) == 0, "NA", as.character(min(.x, na.rm = TRUE) %>% round(2))),
  `_max` = ~ifelse(sum(!is.na(.x)) == 0, "NA", as.character(max(.x, na.rm = TRUE) %>% round(2)))
)

```

``` {r Statictical hypothesis check}
perform_statistical_tests <- function(data, dependent_var, independent_var, variable_name) {
  result_table <- tibble(Variable = character(),
                         Performed_test = character(),
                         Result = character(),
                         Interpretation = character())
  
  # Format p-value helper function
  format_p_value <- function(p) {
    if (p < 0.0001) {
      return("< 0.0001")  # Very small p-values
    } else {
      return(formatC(p, format = "f", digits = 4))  # Standard decimal notation
    }
  }
  
  # Check the type of independent variable
  if (is.numeric(data[[independent_var]])) {
    # If independent variable is numeric
    if (length(data[[independent_var]][!is.na(data[[independent_var]])]) > 3) {
      ad_result <- nortest::ad.test(data[[independent_var]][!is.na(data[[independent_var]])])
      
      if (ad_result$p.value > 0.05) {
        # Normal distribution
        t_test_result <- t.test(data[[independent_var]] ~ as.factor(data[[dependent_var]]), data = data)
        result_table <- result_table %>%
          add_row(
            Variable = variable_name,
            Performed_test = "T-Test",
            Result = format_p_value(t_test_result$p.value),
            Interpretation = ifelse(t_test_result$p.value < 0.05, "Significant", "Not significant")
          )
      } else {
        # Not normally distributed
        if (length(unique(data[[dependent_var]])) == 2) {
          mw_test_result <- wilcox.test(data[[independent_var]] ~ as.factor(data[[dependent_var]]), data = data)
          result_table <- result_table %>%
            add_row(
              Variable = variable_name,
              Performed_test = "Mann-Whitney U Test",
              Result = format_p_value(mw_test_result$p.value),
              Interpretation = ifelse(mw_test_result$p.value < 0.05, "Significant", "Not significant")
            )
        } else {
          stop("Dependent variable must have exactly two levels for Mann-Whitney U Test.")
        }
      }
    } else {
      stop("Not enough data points for Anderson-Darling test.")
    }
    
  } else if (is.factor(data[[independent_var]]) || is.character(data[[independent_var]])) {
    # If independent variable is categorical
    data[[dependent_var]] <- as.factor(data[[dependent_var]])
    contingency_table <- table(data[[independent_var]], data[[dependent_var]])
    
    # Check for zero counts
    if (any(contingency_table == 0)) {
      # Remove rows and columns with all zeros
      contingency_table <- contingency_table[rowSums(contingency_table) > 0, colSums(contingency_table) > 0]
      
      # If the table is now empty, stop with a warning
      if (nrow(contingency_table) == 0 || ncol(contingency_table) == 0) {
        stop("Contingency table is empty after removing zero counts.")
      }
      
      # Optionally merge low-frequency categories into "Other"
      data[[independent_var]] <- as.character(data[[independent_var]])
      low_frequency <- rownames(contingency_table)[rowSums(contingency_table) <= 5]  # Adjust threshold as needed
      data[[independent_var]][data[[independent_var]] %in% low_frequency] <- "Other"
      
      # Recalculate the table
      contingency_table <- table(data[[independent_var]], data[[dependent_var]])
    }
    
    # Perform Chi-Square Test
    chi_square_result <- chisq.test(contingency_table, simulate.p.value = TRUE)
    result_table <- result_table %>%
      add_row(
        Variable = variable_name,
        Performed_test = "Chi-Squared Test",
        Result = format_p_value(chi_square_result$p.value),
        Interpretation = ifelse(chi_square_result$p.value < 0.05, "Significant", "Not significant")
      )
  } else {
    stop("Independent variable must be either numeric or categorical.")
  }
  
  if (nrow(result_table) == 0) {
    stop("No valid tests were performed. Check your data and variables.")
  }
  
  return(result_table)
}


```

``` {r Survival Analysis}
HR_assessment <- function(survival_time, event_status, predictors, data) {
  
  # Create the formula for the Cox model
  formula <- as.formula(paste("Surv(", survival_time, ", ", event_status, ") ~", paste(predictors, collapse = " + ")))
  
  # Fit the Cox model
  cox_model <- coxph(formula, data = data)
  
  # Extract hazard ratios and confidence intervals
  hr <- exp(coef(cox_model))  # Hazard ratios
  hr_ci <- exp(confint(cox_model))  # Confidence intervals
  
  # Extract p-values
  p_values <- summary(cox_model)$coefficients[, "Pr(>|z|)"]
  
  # Get the variable names corresponding to each coefficient
  variable_names <- names(coef(cox_model))
  
  # Format p-values helper function
  format_p_value <- function(p) {
    if (is.na(p)) {
      return("NA")  # Handle missing p-values
    } else if (p < 0.0001) {
      return("< 0.0001")  # Very small p-values
    } else {
      return(formatC(p, format = "f", digits = 4))  # Standard decimal notation
    }
  }
  
  # Add interpretation logic
  interpret_hr <- function(hr) {
    if (is.na(hr)) {
      return("NA")  # Handle missing HRs
    } else if (hr > 1) {
      return("Increased risk")
    } else if (hr == 1) {
      return("No change in risk")
    } else {
      return("Decreased risk")
    }
  }
  
  # Create a tibble with hazard ratios, confidence intervals, p-values, and interpretations
  hr_table <- tibble(
    Variable = variable_names,
    Hazard_Ratio = hr,
    Lower_CI = hr_ci[, 1],
    Upper_CI = hr_ci[, 2],
    p_value = sapply(p_values, format_p_value),  # Apply p-value formatting
    Interpretation = sapply(hr, interpret_hr)   # Apply HR interpretation
  )
  
  # Return the hazard ratio table
  return(hr_table)
}

```

```{r penalized COX Regression}
# Function to run Penalized Cox Regression
run_penalized_cox <- function(data, survival_time, event_status, predictors, penalty = "lasso") {
  # Define alpha based on penalty type
  alpha_value <- ifelse(penalty == "lasso", 1, 0)  # LASSO = 1, Ridge = 0
  
  # Prepare survival object and predictors matrix
  survival_outcome <- with(data, Surv(get(survival_time), get(event_status)))
  predictor_matrix <- model.matrix(~ . -1, data = data[, predictors, drop = FALSE])
  
  # Cross-validated penalized Cox model
  cv_model <- cv.glmnet(
    x = predictor_matrix,
    y = survival_outcome,
    family = "cox",
    alpha = alpha_value
  )
  
  # Get coefficients at optimal lambda
  optimal_coefs <- coef(cv_model, s = "lambda.min")
  
  # Return key results
  list(
    optimal_lambda = cv_model$lambda.min,
    coefficients = optimal_coefs,
    significant_features = rownames(optimal_coefs)[as.matrix(optimal_coefs) != 0],
    cv_model = cv_model
  )
}
```

``` {r LOS Analysis}
analyze_predictor_LOS <- function(data, predictor, LOS, patient_id) {
  
  # Helper function to format p-values
  format_p_value <- function(p) {
    if (p < 0.0001) {
      return("< 0.0001")  # Very small p-values
    } else {
      return(formatC(p, format = "f", digits = 4))  # Standard decimal notation with 4 digits
    }
  }

  # Validate Inputs
  if (!(predictor %in% colnames(data))) {
    stop(paste("Error: Predictor column", predictor, "does not exist in the dataset."))
  }
  if (!(LOS %in% colnames(data))) {
    stop(paste("Error: LOS column", LOS, "does not exist in the dataset."))
  }
  if (!(patient_id %in% colnames(data))) {
    stop(paste("Error: Patient ID column", patient_id, "does not exist in the dataset."))
  }

  # Check if LOS is numeric
  if (!is.numeric(data[[LOS]])) {
    stop("Error: LOS column must be numeric.")
  }

  # Check predictor type
  if (is.numeric(data[[predictor]])) {
    # Numerical predictor: Fit a mixed-effects linear regression model
    model <- lmer(as.formula(paste(LOS, "~", predictor, "+ (1 |", patient_id, ")")), data = data)
    model_summary <- summary(model)

    # Extract fixed-effect estimate and p-value
    fixed_effects <- tibble(
      Variable = predictor,
      Performed_test = "Mixed-Effects Linear Model",
      Statistic = model_summary$coefficients[predictor, "Estimate"],
      P_value = format_p_value(model_summary$coefficients[predictor, "Pr(>|t|)"]),
      Interpretation = ifelse(model_summary$coefficients[predictor, "Pr(>|t|)"] < 0.05, "Significant", "Not Significant")
    )

  } else if (is.factor(data[[predictor]]) || is.character(data[[predictor]])) {
    # Categorical predictor: Fit a mixed-effects linear regression model
    data[[predictor]] <- as.factor(data[[predictor]])  # Ensure it's a factor
    model <- lmer(as.formula(paste(LOS, "~", predictor, "+ (1 |", patient_id, ")")), data = data)
    model_summary <- summary(model)

    # Extract fixed-effect estimates and p-values for all levels of the categorical predictor
    fixed_effects <- as.data.frame(model_summary$coefficients) %>%
      rownames_to_column("Term") %>%
      filter(Term != "(Intercept)") %>%
      mutate(
        Variable = predictor,
        Performed_test = "Mixed-Effects Linear Model",
        Statistic = Estimate,
        P_value = sapply(`Pr(>|t|)`, format_p_value),
        Interpretation = ifelse(`Pr(>|t|)` < 0.05, "Significant", "Not Significant")
      ) %>%
      select(Variable, Term, Performed_test, Statistic, P_value, Interpretation) %>%
      as_tibble()  # Convert to tibble
  } else {
    stop("Error: Predictor must be numeric, factor, or character.")
  }

  # Return the result table as a tibble
  return(fixed_effects)
}

```

```{r styled tables}
# Define the function for styled tables
print_table <- function(table, format = "html", striped = TRUE, hover = TRUE, full_width = FALSE) {
  
  kable(table, format = format, table.attr = "class='table table-bordered'") %>%
    kable_styling(
      bootstrap_options = c(
        if (striped) "striped" else NULL,
        if (hover) "hover" else NULL
      ),
      full_width = full_width
    )
}
```

# 1. Outcomes Data

## 1.1. Read Data

```{r read files}
patients <- read.csv("../data/raw/cleaned/PATIENTS_clean.csv", stringsAsFactors = TRUE) %>%
  mutate(across(c(SUBJECT_ID, EXPIRE_FLAG), as.factor)) %>%
  filter(AGE_AT_ADMISSION > 0)

# Create a vector of SUBJECT_IDs where age > 0
subject_ids_adults <- patients$SUBJECT_ID

# Read the ADMISSIONS dataset and filter using the SUBJECT_ID vector
admissions <- read.csv("../data/raw/cleaned/ADMISSIONS_clean.csv", stringsAsFactors = TRUE) %>%
  filter(SUBJECT_ID %in% subject_ids_adults) %>% # Filter for adult patients 
  mutate(across(c(SUBJECT_ID, HADM_ID, SUBJECT_ID_COMPOSE), as.factor))

# Read the ICUSTAYS dataset and filter using the SUBJECT_ID vector
icu_stays <- read.csv("../data/raw/cleaned/ICUSTAYS_clean.csv", stringsAsFactors = TRUE) %>%
  filter(SUBJECT_ID %in% subject_ids_adults) %>%  # Filter for adult patients
  mutate(across(c(SUBJECT_ID, HADM_ID, ICUSTAY_ID), as.factor)) 
```

## 1.2. Desriptive Statistics and Visualisation Analysis

### 1.2.1. Outcome 1: Death Status

```{r descriptive statistics for death status}
# Death status outcome
Death_status_outcome <- admissions %>%
  select(SUBJECT_ID, SUBJECT_ID_COMPOSE, SURVIVAL_FLAG)

admissions %>%
  select(SURVIVAL_FLAG) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  group_by(Variable, Value) %>%
  summarise(n = n(), .groups = 'drop') %>%
  group_by(Variable) %>%
  mutate(`No data` = sum(is.na(Value)),
         `% by group` = (n / sum(n)) * 100) %>%
  ungroup() %>%
  select(Variable, Value, n, `% by group`, `No data`) %>%
  arrange(Variable, Value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

```{r barplot for death status}
# Visualization for EXPIRE_FLAG in admissions dataset
ggplot(admissions, aes(x = as.factor(SURVIVAL_FLAG), fill = as.factor(SURVIVAL_FLAG))) +
  geom_bar(color = "black") +
  geom_text(
          stat = "count", aes(label = after_stat(count)),
            size = 3, 
            fontface = "bold", 
            vjust = -0.5
    ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(admissions$SURVIVAL_FLAG)), replace = FALSE),
    labels = c("0" = "Not Dead", "1" = "Dead")
    ) +
  labs(
    title = "Distribution of Death Status", x = "Death Status", y = "Count", fill = "Death Status"
    ) +
  theme_custom

```

-   There were 45,007 ICU stays when patient did not die (labeled "Not Dead").
-   There were 5,735 ICU stays when patient died (labeled "Dead").

This indicates that a higher proportion of patients in the dataset survived compared to those who did not. 

### 1.2.2. Outcome 2: Length of Survival

```{r descriptive statistics for length of survival}
# Create Survival_outcome file whith unique SUBJECT_ID and summarise SURVIVAL
Survival_outcome <- admissions %>%
  select(SURVIVAL, SURVIVAL_FLAG, SUBJECT_ID, SUBJECT_ID_COMPOSE)

Survival_outcome %>%
  select(SURVIVAL) %>%
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

**Outliers Check**

``` {r outliers check for length of survival}
# Calculate mean and standard deviation
mean_value <- mean(Survival_outcome$SURVIVAL, na.rm = TRUE)
sd_value <- sd(Survival_outcome$SURVIVAL, na.rm = TRUE)

# Define the 3-sigma range
lower_bound <- mean_value - 3 * sd_value
upper_bound <- mean_value + 3 * sd_value

# Identify outliers
outliers <- Survival_outcome %>%
  filter(SURVIVAL < lower_bound | SURVIVAL > upper_bound)

# Calculate the number and percentage of outliers
num_outliers <- nrow(outliers)
total_values <- nrow(Survival_outcome)
percent_outliers <- (num_outliers / total_values) * 100

# Print the number and percentage of outliers
cat("Number of outliers:", num_outliers, "\n")
cat("Percentage of outliers:", round(percent_outliers, 2), "%\n")

# Filter out the outliers
Survival_outcome <- Survival_outcome %>%
  filter(SURVIVAL >= lower_bound & SURVIVAL <= upper_bound)

# Clean the memory
rm(outliers, mean_value, sd_value, lower_bound, upper_bound, num_outliers, percent_outliers, total_values)
```

Based on the small percentage of outliers observed, it was decided to filter them out. These outliers could potentially represent patients who were in a prolonged coma or had unusually extended hospital stays.

```{r boxplot for length of survival}
# Boxplot for TIMETODEATH
ggplot(Survival_outcome, aes(y = SURVIVAL)) +
  geom_boxplot(fill = color_palette[4], color = "black") +
  labs(title = "Boxplot of Time to Death (in Days)",
       y = "Time to Death (in days)") +
  theme_custom

```

```{r density plot for length of survival}
ggplot(Survival_outcome, aes(x = SURVIVAL)) +
  geom_density(fill = color_palette[14], alpha = 0.7) +
  labs(title = "Density Plot of Time to Death (in Days)",
       x = "Time to Death (in days)",
       y = "Density") +
  theme_custom
```

The boxplot and density plot show that most patients died within 0 to 10 days, with a median around 7 days. There are still several outliers, indicating some patients survived much longer, possibly due to unique conditions such as prolonged illness or coma.

### 1.2.3. Outcome 3: Length of ICU Stay

```{r descriptive statistics for length of ICU stay}
# LOS outcome
LOS_outcome <- icu_stays %>%
  select(SUBJECT_ID, SUBJECT_ID_COMPOSE, ICUSTAY_ID, LOS)

icu_stays %>%
  select(LOS) %>%
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

**Check for outliers**

```{r check for outliers for length of ICU stay}
# Calculate mean and standard deviation for LOS variable
mean_los <- mean(LOS_outcome$LOS, na.rm = TRUE)
sd_los <- sd(LOS_outcome$LOS, na.rm = TRUE)

# Identify outliers using the 3-sigma rule
LOS_outcome$outlier_los <- ifelse(
  LOS_outcome$LOS > (mean_los + 3 * sd_los) | LOS_outcome$LOS < (mean_los - 3 * sd_los),
  TRUE, 
  FALSE
)

# Count the number and percentage of outliers
num_outliers_los <- sum(LOS_outcome$outlier_los, na.rm = TRUE)
percent_outliers_los <- (num_outliers_los / nrow(LOS_outcome)) * 100

# Print results
cat("Number of outliers in LOS:", num_outliers_los, "\n")
cat("Percentage of outliers in LOS:", round(percent_outliers_los, 2), "%\n")

# Filter out the outliers
LOS_outcome <- LOS_outcome %>%
  select(LOS, SUBJECT_ID, SUBJECT_ID_COMPOSE, ICUSTAY_ID, outlier_los) %>%
  filter(outlier_los == FALSE)

# Drop the outlier column after filtering
LOS_outcome$outlier_los <- NULL

# Clean the memory
rm(mean_los, sd_los, num_outliers_los, percent_outliers_los)

```

Based on the relatively small percentage of outliers (2.29%), it was decided to filter them out from the icu_stays dataset. This filtering helps ensure a more robust analysis by excluding extreme cases that could disproportionately impact the results. It's worth noting that some of these outliers could represent unique cases, such as patients in a coma or those with extended ICU stays due to complex medical conditions.

```{r violin plot for length of ICU stay}
ggplot(LOS_outcome, aes(x = "", y = LOS)) +
  geom_violin(fill = color_palette[10], color = "black") +
  geom_boxplot(width = 0.1, fill = "white", outlier.shape = NA) +
  labs(title = "Violin Plot of Length of ICU Stay (LOS)",
       y = "Length of ICU Stay (Days)",
       x = "") +
  theme_custom

```

This plot highlights that most patients had shorter ICU stays, but there are a few cases with extended durations that could represent unique medical conditions or complications.

# 2. Patients Data

## 2.1. Read and Prepare Data

```{r read file patients}
patients <- patients %>%
  mutate(
    DOB = as.POSIXct(DOB, format = "%Y-%m-%d"),
    DOD = as.POSIXct(DOD, format = "%Y-%m-%d")
  ) %>%
  filter(SUBJECT_ID %in% subject_ids_adults) # Filter for adult patients 

skimr::skim(patients %>% select(-ROW_ID, -SUBJECT_ID))
```

## 2.2. Desriptive Statistics

### 2.2.1. Descriptive Statistics for Numerical Variables (Patient data)

```{r descriptive statistics for numerical vars}
# Summarize the statistics for each numeric variable
patients %>%
  select(-ROW_ID, -SUBJECT_ID, -EXPIRE_FLAG) %>%
  select(where(is.numeric)) %>% 
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

### 2.2.2. Descriptive Statistics for Categorical Variables (Patient data)

```{r Descriptive statistics patients for categorical vars}
# Clean and summarize the categorical data for all factor variables
patients %>%
  select(-DOB, -DOD, -SUBJECT_ID, -EXPIRE_FLAG) %>%
  select(where(is.factor)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  group_by(Variable, Value) %>%
  summarise(n = n(), .groups = 'drop') %>%
  group_by(Variable) %>%
  mutate(`No data` = sum(is.na(Value)),
         `% by group` = (n / sum(n)) * 100) %>%
  ungroup() %>%
  select(Variable, Value, n, `% by group`, `No data`) %>%
  arrange(Variable, Value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

## 2.3. Visualisation Analysis by Outcome

### 2.3.1. Outcome 1: Death Status by Patients Data

```{r death status by gender}
patients_death_status <- Death_status_outcome %>%
  left_join(patients, by = "SUBJECT_ID") %>%
  select(SUBJECT_ID, AGE_AT_ADMISSION, GENDER, SURVIVAL_FLAG) %>%
  distinct() %>%
  mutate(SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG))  # Convert to factor

ggplot(patients_death_status, aes(x = GENDER, fill = SURVIVAL_FLAG)) +
  geom_bar(position = position_dodge2(width = 0.9), color = "black") +
  geom_text(
    stat = 'count', aes(label = after_stat(count)),
    position = position_dodge2(width = 0.9), vjust = -0.5
  ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(patients_death_status$SURVIVAL_FLAG)), replace = FALSE),
    labels = c("0" = "Survive", "1" = "Died")
  ) +
  labs(
    title = "Death Status by Gender",
    x = "Gender",
    y = "Count",
    fill = "Death Status"
  ) +
  theme_custom 
```

-   Males (M) have a higher count in both survival (19,569) and death (3,068) categories compared to females.
-   Females (F) have a lower count, with 14,707 surviving and 2,652 deceased.

This suggests that while the total number of male patients is higher, the proportion of deceased individuals appears similar across genders.

```{r death status by age at admission}
ggplot(patients_death_status, aes(x = AGE_AT_ADMISSION, fill = SURVIVAL_FLAG)) +
  geom_histogram(binwidth = 5, alpha = 0.6, position = "identity", color = "black") +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(patients_death_status$SURVIVAL_FLAG))), 
    labels = c("0" = "Survive", "1" = "Died")
    ) +
  labs(title = "Death Status by Age at Admission", 
       x = "Age at Admission", 
       y = "Count", 
       fill = "Death Status") +
  theme_custom
```

The histogram shows that most patients are admitted between 50–80 years, with survival dominating across all ages. However, the proportion of deaths increases with age, especially after 75, indicating that older patients are more likely to die. Age is clearly a key factor influencing mortality.

During the exploratory data analysis, a significant spike in admissions for newborns (age 0) was observed, with the vast majority of these infants being alive. After careful consideration, it was decided to exclude the data for newborns (age 0) from our analysis.

**Rationale for Removal:**
1. Different Health Dynamics in Newborns

Newborns (age 0) have distinct health characteristics and mortality patterns compared to older children and adults. Their admissions are often related to birth-related complications, immediate post-birth care, or congenital conditions. These factors may not be directly relevant to the survival analysis intended for the rest of the population.
The survival dynamics for newborns are very different from those for older children or adults, making it difficult to generalize survival factors across the age spectrum when newborns are included.

2. Survival Bias in Newborns

The vast majority of newborns survive, which introduces a potential survival bias into the analysis. Since survival outcomes for newborns are typically skewed toward "alive" (due to medical advances in neonatal care), their inclusion could dilute the significance of other age groups and make it harder to detect meaningful survival trends.
Including newborns could potentially lead to misleading conclusions about the effect of age on survival outcomes, as the survival rate for age 0 is much higher compared to other age groups, thus overshadowing the variability observed in older patients.
Distortion of Survival Model Results:

The presence of a large proportion of patients who survive (newborns) can distort the results of a survival analysis. If survival outcomes for newborns (age 0) are predominantly "alive," they can skew the overall survival curve, potentially masking or distorting the real relationship between age and survival in older populations.
By excluding newborns, we ensure that the survival analysis reflects more accurate and relevant survival patterns across the broader population, without the confounding effect of newborn health outcomes.

### 2.3.2. Outcome 2: Length of Survival by Patients Data

```{r length of survival by age and gender}
# Merge admissions with patients data to include AGE_AT_ADMISSION
patients_survival_outcome <- Survival_outcome %>%
  left_join(patients, by = "SUBJECT_ID") %>%
  select(SUBJECT_ID, AGE_AT_ADMISSION, GENDER, SURVIVAL_FLAG, SURVIVAL) %>%
  distinct() %>%
  mutate(SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG))  # Convert to factor

ggplot(patients_survival_outcome, aes(x = AGE_AT_ADMISSION, y = SURVIVAL, color = GENDER)) +
  geom_point(alpha = 0.7, size = 2, shape = 16, stroke = 0.3) +  # Scatter points
  geom_smooth(method = "lm", se = TRUE, size = 1, linetype = "solid", alpha = 0.2, colour = "grey40") +  # Add linear regression line
  labs(
    title = "Length of Survival by Age",
    x = "Age at Admission",
    y = "Time to Death (Days)",
    color = "Gender"
  ) +
  scale_color_manual(
    values = sample(color_palette, size = length(unique(patients_survival_outcome$GENDER)), replace = FALSE)
  ) +
  theme_custom +
  theme(
    panel.grid.major = element_line(color = "grey90", size = 0.5),
    legend.position = "right"
  )

# Create a new age group column based on quintiles
age_breaks <- quantile(patients_survival_outcome$AGE_AT_ADMISSION, probs = seq(0, 1, 0.2), na.rm = TRUE)
age_labels <- paste0("(", round(head(age_breaks, -1)), "-", round(tail(age_breaks, -1)), "]")

patients_survival_outcome <- patients_survival_outcome %>%
  mutate(AGE_QUINTILE = cut(AGE_AT_ADMISSION, 
                            breaks = age_breaks,
                            include.lowest = TRUE,
                            labels = age_labels))

# Plot including age quintiles as facets
ggplot(patients_survival_outcome, aes(x = GENDER, y = SURVIVAL, fill = GENDER)) +
  geom_boxplot() +
  facet_wrap(~ AGE_QUINTILE, ncol = 3) +  # Facet by age quintiles
  labs(title = "Length of Survival by Gender and Age Quintile",
       x = "Gender",
       y = "Time to Death (Days)") +
  scale_fill_manual(values = sample(color_palette, size = length(unique(patients_survival_outcome$GENDER)))) +
  theme_custom

ggplot(patients_survival_outcome, aes(x = SURVIVAL, y = as.factor(AGE_QUINTILE), fill = GENDER, color = GENDER)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7, position = position_dodge2(preserve = "single")) +
  geom_jitter(width = 0.2, alpha = 0.5, size = 1.5) +
  facet_wrap(~GENDER, scales = "free_y") +
  scale_fill_manual(values = sample(color_palette, size = length(unique(patients_survival_outcome$GENDER)), replace = FALSE)) +
  scale_color_manual(values = sample(color_palette, size = length(unique(patients_survival_outcome$GENDER)), replace = FALSE)) +
  labs(
    title = "Time to Death by Age Quintile for Males and Females",
    y = "Age Quintile",
    x = "Time to Death (Days)",
    fill = "Gender",
    color = "Gender"
  ) +
  theme_custom +
  theme(
    legend.position = "right",
    strip.text = element_text(size = 12, face = "bold")
  )

rm(age_breaks, age_labels)

```

The plots allow for the visualization of how gender and age interact to influence survival times.

*Scatter Plot: Length of Survival by Age*

- No clear correlation between age at admission and time to death. Survival time is distributed across all age groups.
- Both male and female distributions appear similar, with no noticeable trend favoring one gender.

*Faceted Scatter Plot: Time to Death by Age Quintile and Gender*

- Age Quintiles: Older age groups (e.g., 80-93) show slightly higher clustering of shorter survival times.
- Within each age group, survival patterns for males and females are similar, indicating no strong gender-based differences in survival outcomes.

### 2.3.3. Outcome 3: Length of ICU Stay by Patients Data

```{r length of ICU stay by gender and age}
# Merge icu_stays with patients data to include AGE_AT_ADMISSION
patients_los_outcome <- LOS_outcome %>%
  left_join(patients, by = "SUBJECT_ID") %>%
  select(SUBJECT_ID, SUBJECT_ID_COMPOSE, LOS, AGE_AT_ADMISSION, GENDER)

ggplot(patients_los_outcome, aes(x = AGE_AT_ADMISSION, y = LOS, color = GENDER)) +
  geom_point(alpha = 0.7, size = 2, shape = 16, stroke = 0.3) +  # Scatter points
  geom_smooth(method = "lm", se = TRUE, size = 1, linetype = "solid", alpha = 0.2, colour = "grey40") +  # Add linear regression line
  labs(
    title = "Length of Stay (LOS) by by Age",
    x = "Age at Admission",
    y = "Length of Stay (Days)",
    color = "Gender"
  ) +
  scale_color_manual(
    values = sample(color_palette, size = length(unique(patients_los_outcome$GENDER)), replace = FALSE)
  ) +
  theme_custom +
  theme(
    panel.grid.major = element_line(color = "grey90", size = 0.5),
    legend.position = "right"
  )

# Create a new age group column based on quintiles
age_breaks_los <- quantile(patients_los_outcome$AGE_AT_ADMISSION, probs = seq(0, 1, 0.2), na.rm = TRUE)
age_labels_los <- paste0("(", round(head(age_breaks_los, -1)), "-", round(tail(age_breaks_los, -1)), "]")

patients_los_outcome <- patients_los_outcome %>%
  mutate(AGE_QUINTILE = cut(AGE_AT_ADMISSION, 
                             breaks = age_breaks_los,
                             include.lowest = TRUE,
                             labels = age_labels_los))

# Plot including age quintiles as facets for Length of Stay (LOS)
ggplot(patients_los_outcome, aes(x = GENDER, y = LOS, fill = GENDER)) +
  geom_boxplot() +
  facet_wrap(~ AGE_QUINTILE, ncol = 3) +
  labs(title = "Length of Stay (LOS) by Gender and Age Quintile",
       x = "Gender",
       y = "Length of Stay (Days)") +
  scale_fill_manual(values = sample(color_palette, size = length(unique(patients_los_outcome$GENDER)))) +
  theme_custom

rm(age_breaks_los, age_labels_los)
```

There is no strong trend indicating that age at admission directly correlates with the length of Stay (Days).
Gender Difference: Both genders (F and M) show similar distributions of length of Stay (Days) across all ages.

## 2.4. Exploratory analysis

### 2.4.1. Outcome 1: Death Status by Patients Data

```{r Death Status by Patients Data Exploratory analysis}
# Perform the statistical tests for both variables
result_age <- perform_statistical_tests(patients_death_status, "SURVIVAL_FLAG", "AGE_AT_ADMISSION", "Age")
result_sex <- perform_statistical_tests(patients_death_status, "SURVIVAL_FLAG", "GENDER", "Gender")

# Merge the results
merged_results <- bind_rows(result_age, result_sex)

print_table(merged_results)

rm(result_age, result_sex, merged_results)
```

*Age:* The Mann-Whitney U Test result (< 0.0001) indicates a significant difference in death status based on age.
*Gender:* The Chi-Squared Test result (0.0005) shows a significant association between gender and death status.

Both **Age and Gender** show highly significant associations with death status (SURVIVAL_FLAG), suggesting they are both important variables in explaining survival outcomes in this dataset.

### 2.4.2. Outcome 2: Length of Survival by Patients Data

```{r Length of Survival by Patients DataExploratory analysis}
patients_survival_outcome <- patients_survival_outcome %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )
  
# Generate Kaplan-Meier survival curve by GENDER
fit_gender <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ GENDER, data = patients_survival_outcome)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_gender,
  data = patients_survival_outcome,
  pval = TRUE,  # Display p-value for age groups
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Age Group",
  title = "Survival Curve by Age Group",
  palette = color_palette
)

# Create age groups based on AGE_AT_ADMISSION
patients_survival_outcome <- patients_survival_outcome %>%
  mutate(
    AGE_GROUP = cut(AGE_AT_ADMISSION,
                    breaks = c(0, 18, 40, 60, 100), 
                    labels = c("0-18", "19-40", "41-60", "61+"),
                    right = FALSE)  # Include the left boundary in each group
  )

# Fit the Kaplan-Meier survival curve by age group
fit_age_group <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ AGE_GROUP, data = patients_survival_outcome)

# Plot the Kaplan-Meier curve for the age groups
ggsurvplot(
  fit_age_group,
  data = patients_survival_outcome,
  pval = TRUE,  # Display p-value for age groups
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Age Group",
  title = "Survival Curve by Age Group",
  palette = color_palette
)

hr_table <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", c("GENDER", "AGE_AT_ADMISSION"), patients_survival_outcome)

print_table(hr_table)

rm(hr_table, fit_age_group, fit_gender, patients_survival_outcome)
```

*Age at Admission:* This factor has a strong and highly significant association with mortality (p < 0.0001). Its hazard ratio (HR = 1.026) indicates that the risk of death increases with age, making it a crucial variable for predictive models.

*Gender:* Although statistically significant (p = 0.0128), the hazard ratio (HR = 0.935) suggests a small effect size. You could include gender in the model, especially if other analyses or prior knowledge suggest its importance as a confounder or interacting variable.

### 2.4.3. Outcome 3: Length of ICU Stay by Patients Data

``` {r Length of ICU Stay by Patients Data}

result_age <- analyze_predictor_LOS(patients_los_outcome, predictor = "AGE_AT_ADMISSION", LOS = "LOS", patient_id = "SUBJECT_ID")
result_sex <- analyze_predictor_LOS(patients_los_outcome, predictor = "GENDER", LOS = "LOS", patient_id = "SUBJECT_ID")

# Merge the results
merged_results <- bind_rows(result_age, result_sex)
print_table(merged_results)

rm(patients, merged_results, result_age, result_sex, patients_los_outcome)
```

*Age at Admission:*

- The mixed-effects linear model indicates a significant association between Age at Admission and Length of Stay in ICU (p < 0.0001).
- The positive coefficient (Statistic = 0.0053) suggests that older patients tend to have slightly longer ICU stays.

*Gender:*

- The model does not show a significant association between Gender and Length of Stay in ICU (p = 0.6624).
- This indicates that gender is unlikely to influence ICU stay duration in this dataset.

# 3. Admissions Data

## 3.1. Read and Prepare Data

```{r read file}
skimr::skim(admissions %>%
              select(-HADM_ID, -SUBJECT_ID, -SUBJECT_ID_COMPOSE) %>%
            mutate(
              SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG)
            ))
```

## 3.2. Desriptive statistics

### 3.2.1. Descriptive statistics for categorical variables (Admission data)

```{r descriptive statistica admissions}
# Clean and summarize the categorical data for all factor variables
admissions %>%
  select(ADMISSION_TYPE, INSURANCE, RELIGION, MARITAL_STATUS, ETHNICITY) %>%
  select(where(is.factor)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  group_by(Variable, Value) %>%
  summarise(n = n(), .groups = 'drop') %>%
  group_by(Variable) %>%
  mutate(`No data` = sum(is.na(Value)),
         `% by group` = (n / sum(n)) * 100) %>%
  ungroup() %>%
  select(Variable, Value, n, `% by group`, `No data`) %>%
  arrange(Variable, Value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

## 3.3. Visualisation Analysis by Outcome
### 3.3.1. Outcome 1: Death Status by Admissions Data

```{r death status by admissions data}
admissions_death_outcome <- admissions %>%
  select(SURVIVAL_FLAG, SUBJECT_ID, SUBJECT_ID_COMPOSE, ADMISSION_TYPE, INSURANCE, RELIGION, MARITAL_STATUS, ETHNICITY)

# Prepare the data for plotting
admissions_death_outcome_long <- admissions_death_outcome %>%
  pivot_longer(cols = -SURVIVAL_FLAG, names_to = "Variable", values_to = "Value")

# List of categorical variables to plot
categorical_vars <- c("ADMISSION_TYPE", "INSURANCE", "RELIGION", "MARITAL_STATUS", "ETHNICITY")

# Loop through each variable and create a bar plot
for (var in categorical_vars) {
  p <- ggplot(admissions_death_outcome_long[admissions_death_outcome_long$Variable == var, ], aes(x = Value, fill = as.factor(SURVIVAL_FLAG))) +
    geom_bar(position = "dodge2", color = "black") +
    geom_text(stat = "count", aes(label = after_stat(count)), 
              position = position_dodge(width = 0.9), 
              vjust = -0.5, size = 3) +  # Adjust label position and size
    labs(title = paste("Death Status by", var),
         x = "Category",
         y = "Count",
         fill = "Death Status") +
    theme_custom +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels
    scale_fill_manual(values = sample(color_palette, size = length(unique(admissions$SURVIVAL_FLAG))), labels = c("0" = "Survived", "1" = "Died"))
  
  # Print or save the plot
  print(p)
}

rm(p, categorical_vars, admissions_death_outcome_long)

```

*Admission Type:* Emergency admissions are associated with higher mortality, likely reflecting the severity of cases. Elective admissions, often planned and less acute, show lower death rates.

*Insurance:* Patients with Medicare, predominantly older individuals, have higher mortality, emphasizing age and associated comorbidities as risk factors.

*Religion:* Christianity and "Unknown" categories account for the majority of cases. This could reflect demographic prevalence in the population or limitations in data recording.

*Ethnicity:* White ethnicity dominates the data, with a notable survival rate but also the largest death count. Lower representation of other ethnicities may require further investigation for equity in care and outcomes.

### 3.3.2. Outcome 2: Length of Survival by Admissions Data

``` {r Outcome 2: Length of Survival by Admissions Data visualisation}
admissions_survival_outcome <- admissions %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL, SURVIVAL_FLAG, ADMISSION_TYPE, INSURANCE, RELIGION, MARITAL_STATUS, ETHNICITY) %>%
  mutate(SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG))

# Function to create the plot
create_admission_plot <- function(data, x_var, color_var, color_palette, theme_custom) {
  ggplot(data, aes_string(x = x_var, y = "SURVIVAL", fill = x_var, color = color_var)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(width = 0.2, alpha = 0.7, fill = "white", shape = 21, size = 2, stroke = 0.5) +
    theme_custom +
    scale_fill_manual(values = color_palette) +
    scale_color_manual(values = c("black", "blue")) +
    labs(
      title = paste("Time to Death by", x_var),
      y = "Time to Death (Days)", x = x_var,
      color = "Survival Status"  # Add legend label
    ) +
    theme(
      legend.position = "right",  # Show the legend for SURVIVAL_FLAG
      strip.text = element_text(size = 12, face = "bold"),
      axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels
    )
}

# Define the admission variables
admission_vars <- c("ADMISSION_TYPE", "INSURANCE", "MARITAL_STATUS", "ETHNICITY", "RELIGION")

# Create a list to store the plots
plots <- lapply(admission_vars, function(var) {
  create_admission_plot(admissions_survival_outcome, var, "SURVIVAL_FLAG", color_palette, theme_custom)
})

# Name the plots for easy reference
names(plots) <- admission_vars
for (var_name in names(plots)) {
  print(plots[[var_name]])
}

rm(plots, admission_vars, create_admission_plot, var_name, var)
``` 

Across these plots, admission type, insurance, and marital status appear to have significant influence on survival variability. These factors could be explored further in predictive modeling to understand their direct or indirect impact on survival outcomes. Ethnicity and religion may require more robust representation for conclusive insights.


### 3.3.3. Outcome 3: Length of ICU Stay by Admissions Data

``` {r Outcome 3: Length of ICU Stay by Admissions Data visualisation}
# Clean and prepare the data
admissions_los_outcome <- admissions %>%
  left_join(LOS_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL, SURVIVAL_FLAG, ADMISSION_TYPE, INSURANCE, RELIGION, MARITAL_STATUS, ETHNICITY, LOS) %>%
  mutate(SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG))

# Function to create the plot
create_LOS_plot <- function(data, x_var, color_var, color_palette, theme_custom) {
  ggplot(data, aes_string(x = x_var, y = "LOS", fill = x_var, color = color_var)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(width = 0.2, alpha = 0.4, fill = "white", shape = 21, size = 2, stroke = 0.5) +
    theme_custom +
    scale_fill_manual(values = color_palette) +
    scale_color_manual(values = c("black", "blue")) +
    labs(
      title = paste("Length of ICU Stay by", x_var),
      y = "Length of ICU Stay (Days)", x = x_var,
      color = "Survival Status"  # Add legend label
    ) +
    theme(
      legend.position = "right",  # Show the legend for SURVIVAL_FLAG
      strip.text = element_text(size = 12, face = "bold"),
      axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels
    )
}

# Define the admission variables
admission_vars <- c("ADMISSION_TYPE", "INSURANCE", "MARITAL_STATUS", "ETHNICITY", "RELIGION")

# Create a list to store the plots
plots <- lapply(admission_vars, function(var) {
  create_LOS_plot(admissions_los_outcome, var, "SURVIVAL_FLAG", color_palette, theme_custom)
})

# Name the plots for easy reference
names(plots) <- admission_vars
for (var_name in names(plots)) {
  print(plots[[var_name]])
}

rm(plots, admission_vars, create_LOS_plot, var_name, var)
```

While categorical variables such as admission type, insurance, marital status, ethnicity, and religion show some variability in ICU stays, survival status does not appear to significantly impact the duration within these groups. The most substantial differences are seen in admission type and insurance categories, suggesting these factors could be explored further for ICU resource management or predictive modeling.

## 3.4. Exploratory analysis
### 3.4.1. Outcome 1: Death Status by Admissions Data

```{r Death Status by Admissions Data }
admissions_death_outcome <- admissions_death_outcome %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(as.character(SURVIVAL_FLAG))  # Ensure EXPIRE_FLAG is numeric
  )

# Perform the statistical tests for both variables
admissions_death_outcome$ADMISSION_TYPE <- droplevels(admissions_death_outcome$ADMISSION_TYPE)

result_ADMISSION_TYPE <- perform_statistical_tests(admissions_death_outcome, "SURVIVAL_FLAG", "ADMISSION_TYPE", "ADMISSION TYPE")
result_INSURANCE <- perform_statistical_tests(admissions_death_outcome, "SURVIVAL_FLAG", "INSURANCE", "INSURANCE")
result_RELIGION <- perform_statistical_tests(admissions_death_outcome, "SURVIVAL_FLAG", "RELIGION", "RELIGION")
result_MARITAL_STATUS <- perform_statistical_tests(admissions_death_outcome, "SURVIVAL_FLAG", "MARITAL_STATUS", "MARITAL STATUS")
result_ETHNICITY <- perform_statistical_tests(admissions_death_outcome, "SURVIVAL_FLAG", "ETHNICITY", "ETHNICITY")

# Merge the results
merged_results <- bind_rows(result_ADMISSION_TYPE, result_INSURANCE, result_RELIGION, result_MARITAL_STATUS, result_ETHNICITY)

print_table(merged_results)

rm(result_ADMISSION_TYPE, result_ETHNICITY, result_INSURANCE, result_MARITAL_STATUS, result_RELIGION, merged_results)

```

All tested variables—Admission Type, Insurance, Religion, Marital Status, and Ethnicity—demonstrated statistically significant associations with death status in the Chi-Squared tests (p-value = 0.0005). This indicates that these variables may influence the likelihood of survival or death among patients.

Since all variables show significant associations with the outcome (death status), they are strong candidates for inclusion in predictive models for mortality risk.

### 3.4.2. Outcome 2: Length of Survival by Admissions Data

```{r Length of Survival by Admissions Data exploratory analysis}
admissions_survival_outcome <- admissions_survival_outcome %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(as.character(SURVIVAL_FLAG))  # Ensure EXPIRE_FLAG is numeric
  )

admissions_survival_outcome$ADMISSION_TYPE <- droplevels(admissions_survival_outcome$ADMISSION_TYPE)

# Generate Kaplan-Meier survival curve by GENDER
fit_admission_type <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ ADMISSION_TYPE, data = admissions_survival_outcome)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_admission_type,
  data = admissions_survival_outcome,
  pval = TRUE,  # Display p-value for gender
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Admission type",
  title = "Survival Curve by Admission Type",
  palette =  color_palette
)

# Generate Kaplan-Meier survival curve by GENDER
fit_insurance <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ INSURANCE, data = admissions_survival_outcome)

# Plot the Kaplan-Meier curve 
ggsurvplot(
  fit_insurance,
  data = admissions_survival_outcome,
  pval = TRUE,  # Display p-value for age groups
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Insurance",
  title = "Survival Curve by Insurance",
  palette = color_palette
)

# Fit Kaplan-Meier model
fit_religion <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ RELIGION, data = admissions_survival_outcome)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_religion,
  data = admissions_survival_outcome,
  pval = TRUE,  # Display p-value
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Religion",
  title = "Survival Curve by Religion",
  palette = color_palette
)

# Fit Kaplan-Meier model
fit_marital_status <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ MARITAL_STATUS, data = admissions_survival_outcome)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_marital_status,
  data = admissions_survival_outcome,
  pval = TRUE,  # Display p-value
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Marital Status",
  title = "Survival Curve by Marital Status",
  palette = color_palette
)

# Fit Kaplan-Meier model
fit_ethnicity <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ ETHNICITY, data = admissions_survival_outcome)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_ethnicity,
  data = admissions_survival_outcome,
  pval = TRUE,  # Display p-value
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Ethnicity",
  title = "Survival Curve by Ethnicity",
  palette = color_palette
)

hr_table <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", c("ADMISSION_TYPE", "INSURANCE", "MARITAL_STATUS", "RELIGION", "ETHNICITY"), admissions_survival_outcome)

print_table(hr_table)

rm(admissions_survival_outcome, hr_table, fit_religion, fit_admission_type, fit_ethnicity, fit_insurance, fit_marital_status)

```

Variables with significant p-values (< 0.05), such as admission type, insurance type (except Medicaid), marital status, religion, and ethnicity, should be included in survival modeling as they demonstrate a clear relationship with the risk of death.

### 3.4.3. Outcome 3: Length of ICU Stay by Admissions Data

``` {r Length of ICU Stay by Admission Data}
admissions_los_outcome <- admissions_los_outcome %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(as.character(SURVIVAL_FLAG))
  )
  
result_ADMISSION_TYPE <- analyze_predictor_LOS(admissions_los_outcome, predictor = "ADMISSION_TYPE", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
result_INSURANCE <- analyze_predictor_LOS(admissions_los_outcome, predictor = "INSURANCE", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
result_RELIGION <- analyze_predictor_LOS(admissions_los_outcome, predictor = "RELIGION", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
result_MARITAL_STATUS <- analyze_predictor_LOS(admissions_los_outcome, predictor = "MARITAL_STATUS", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
result_ETHNICITY <- analyze_predictor_LOS(admissions_los_outcome, predictor = "ETHNICITY", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")

# Merge the results
merged_results <- bind_rows(result_ADMISSION_TYPE, result_INSURANCE, result_RELIGION, result_MARITAL_STATUS, result_ETHNICITY)

print_table(merged_results)

rm(admissions, admissions_los_outcome, merged_results, result_RELIGION, result_MARITAL_STATUS, result_ADMISSION_TYPE, result_INSURANCE, result_ETHNICITY)
```

Significant predictors with p < 0.05, such as:
- Admission Type (Emergency, Urgent)
- Insurance (Medicare, Self Pay)
- Religion (Judaism, Unknown)

# 4.   Diagnoses Data
## 4.1.   Read Data

``` {r read data diagnoses}
diagnoses <- read.csv("../data/raw/cleaned/DIAGNOSES_ICD_clean.csv", stringsAsFactors = TRUE) %>%
  mutate(across(where(is.character), as.factor))  %>%
  filter(SUBJECT_ID %in% subject_ids_adults) %>%
  mutate(SUBJECT_ID = as.factor(SUBJECT_ID))

skimr::skim(diagnoses %>%
              select(-SUBJECT_ID, -SUBJECT_ID_COMPOSE, -ROW_ID))
```

## 4.2.   Descriptive Statistics
### 4.2.1. Descriptive statistics for numerical variables (Diagnoses)

```{r descriptive statistics for numerical vars (Diagnoses)}
# Summarize the statistics for each numeric variable
diagnoses %>%
  select(SUBJECT_ID_COMPOSE, DIAGNOSES_NUM) %>%
  distinct() %>% # one number for 1 patient
  select(DIAGNOSES_NUM) %>%
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

### 4.2.2. Descriptive statistics for categorical variables (Diagnoses)

```{r Descriptive statistics patients for categorical vars (Diagnoses)}
# Clean and summarize the categorical data for all factor variables
diagnoses %>%
  filter(SEQ_NUM == 1) %>%
  select(where(is.factor), -SHORT_TITLE, -ICD9_CODE) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  group_by(Variable, Value) %>%
  summarise(n = n(), .groups = 'drop') %>%
  group_by(Variable) %>%
  mutate(`No data` = sum(is.na(Value)),
         `% by group` = (n / sum(n)) * 100) %>%
  ungroup() %>%
  filter(n >= 100) %>% # Keep only rows with at least 1000 observations
  select(Variable, Value, n, `% by group`, `No data`) %>%
  arrange(Variable, desc(n), Value) %>% # Sort by Variable and descending frequency (n)
  flextable() %>%
  merge_v("Variable") %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))

```

```{r Transform data diagnoses}
unique_diagnosis <- diagnoses %>%
  filter(SEQ_NUM == 1) %>%
  count(ICD9_CODE) %>%
  filter(n > 500) %>%
  pull(ICD9_CODE)
  
# Filter and select relevant columns
diagnoses_transformed <- diagnoses %>%
  filter(ICD9_CODE %in% unique_diagnosis) %>%
  select(-ROW_ID, -SUBJECT_ID, -HADM_ID, -SEQ_NUM, -SHORT_TITLE, -LONG_TITLE)  %>%
  distinct() %>%
  mutate(PRESENT = 1) %>%  # Add flag for presence
# Pivot longer and one-hot encode ICD9_CODE
  mutate(PRESENT = 1) %>%  # Add flag for presence
  pivot_wider(
    names_from = ICD9_CODE,
    values_from = PRESENT,
    values_fill = list(PRESENT = NA)
  ) %>%
  select(-DIAGNOSES_NUM) %>%
  rename_with(~ paste0("ICD9_", .), -SUBJECT_ID_COMPOSE)

diagnoses_transformed <- diagnoses_transformed %>%
  group_by(SUBJECT_ID_COMPOSE) %>%
  summarise(
    across(
      everything(), 
      ~ if (all(is.na(.))) NA else na.omit(.)[1], # Keep the first non-NA value
      .names = "{.col}"
    )
  ) %>%
  ungroup() %>%
  mutate(
    across(everything(), ~ replace_na(., 0)),
        across(where(is.numeric), as.factor)
  ) 

```

## 4.3. Visualisation Analysis by Outcome
### 4.3.1. Outcome 1: Death Status by Diagnoses

``` {r Death Status by Diagnoses}
# Visualize how distributes diagnoses with high-priority diagnosis
high_priority <- diagnoses %>%
  filter(SEQ_NUM == 1) %>%
  count(LONG_TITLE, sort = TRUE) %>%
  mutate(Percentage = n / sum(n) * 100,
         Cumulative_Percentage = cumsum(Percentage)) %>%
  filter(Cumulative_Percentage <= 35) # Keep diagnoses contributing to top 30%

ggplot(high_priority, aes(x = reorder(LONG_TITLE, -n), y = n)) +
  geom_bar(stat = "identity", fill = color_palette[6], color = "black") +
  geom_text(aes(label = n), hjust = 1.2, size = 3) +
  labs(title = "High-Priority Diagnoses (contributing to top 35%)",
       x = "ICD9 Code",
       y = "Frequency") +
  theme_custom +
  coord_flip() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Visualize how many diagnoses (DIAGNOSES_NUM unique number for each patients) has patients who died and who not 

diagnoses_death_outcome <- Death_status_outcome %>%
  left_join(diagnoses, by = "SUBJECT_ID_COMPOSE") %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, LONG_TITLE, SEQ_NUM, DIAGNOSES_NUM)

# Simplified dataset: Ensure DIAGNOSES_NUM is directly used
diagnoses_death_summary <- diagnoses_death_outcome %>%
  group_by(SURVIVAL_FLAG) %>%
  summarise(
    Mean_Diagnoses = mean(DIAGNOSES_NUM, na.rm = TRUE),
    Median_Diagnoses = median(DIAGNOSES_NUM, na.rm = TRUE),
    Count = n(),
    .groups = "drop"
  )

# Bar plot: Average number of diagnoses by death status
ggplot(diagnoses_death_summary, aes(x = factor(SURVIVAL_FLAG), y = Mean_Diagnoses, fill = factor(SURVIVAL_FLAG))) +
  geom_bar(stat = "identity", position = "dodge", width = 0.6, color = "black") +
  geom_text(aes(label = round(Mean_Diagnoses, 1)), vjust = -0.5, size = 3) +
  labs(title = "Mean Number of Diagnoses by Death Status",
       x = "Death Status (0 = Survived, 1 = Died)",
       y = "Mean Number of Diagnoses",
       fill = "Death Status") +
  scale_fill_manual(values = sample(color_palette, size = length(unique(diagnoses_death_summary$SURVIVAL_FLAG)), replace = FALSE), labels = c("0" = "Not Dead", "1" = "Dead")) +
  theme_custom +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))

rm(high_priority, diagnoses_death_summary)
```

The bar chart highlights the most frequently occurring diagnoses contributing to adverse outcomes or higher mortality. The top diagnosis, "Coronary atherosclerosis of native coronary artery," appears 3496 times, indicating a significant health concern.

Other critical conditions such as "Unspecified septicemia" (2064 instances) and "Subendocardial infarction, initial episode of care" (1750 instances) also prominently feature, showing their relevance in critical care settings.

Patients who died had a higher mean number of diagnoses (18.4) compared to those who survived (16.7).
This indicates a potential association between the complexity of a patient's medical history (measured by the number of diagnoses) and mortality.

```{r Visualise ICD9 codes over Death Status}
diagnoses_transformed_death_outcome <- Death_status_outcome %>%
  left_join(diagnoses_transformed, by = c("SUBJECT_ID_COMPOSE")) %>%
  select(-SUBJECT_ID)

# Pivot the data to long format and filter for presence (1)
icd9_summary <- diagnoses_transformed_death_outcome %>%
  pivot_longer(
    cols = -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG),  # Pivot ICD9 code columns
    names_to = "ICD9_CODE",
    values_to = "Presence"
  ) %>%
  filter(Presence == 1) %>%  # Keep only rows where ICD9 code is present
  group_by(ICD9_CODE, SURVIVAL_FLAG) %>%  # Group by ICD9 code and survival flag
  summarise(Count = n_distinct(SUBJECT_ID_COMPOSE), .groups = "drop") %>% # Count unique subjects
  arrange(desc(Count))  
  
  ggplot(icd9_summary, aes(x = ICD9_CODE, y = Count, fill = as.factor(SURVIVAL_FLAG))) +
  geom_bar(stat = "identity", position = "dodge2", color = "black") +
  scale_fill_manual(values = c("0" = color_palette[12], "1" = color_palette[1]), name = "Survival Status") +
  theme_custom +
  labs(
    title = "Number of Subjects per ICD9 Code by Survival Status",
    x = "ICD9 Code",
    y = "Number of Subjects"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

### 4.3.2. Outcome 2: Length of Survival by Diagnoses

```{r length of survival by diagnoses}
# Merge admissions and high-priority diagnoses
top_diagnoses <- diagnoses %>%
  filter(SEQ_NUM == 1) %>%
  count(LONG_TITLE, sort = TRUE) %>%
  mutate(Percentage = n / sum(n) * 100,
         Cumulative_Percentage = cumsum(Percentage)) %>%
  filter(Cumulative_Percentage <= 35) %>%
  select(LONG_TITLE)

# Join with survival_outcome to retain survival data
diagnoses_admissions_high_priority <- Survival_outcome %>%
  left_join(diagnoses, by = "SUBJECT_ID_COMPOSE") %>% 
  filter(SEQ_NUM == 1, LONG_TITLE %in% top_diagnoses$LONG_TITLE)

# Plot: High-priority diagnosis by SURVIVAL length
ggplot(diagnoses_admissions_high_priority, aes(x = LONG_TITLE, y = SURVIVAL, fill = LONG_TITLE, color = as.factor(SURVIVAL_FLAG))) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.5, fill = "white", shape = 21, size = 2, stroke = 0.5) +
  labs(title = "High-Priority Diagnoses by Survival Length",
       x = "High-Priority Diagnosis",
       y = "Survival Length (Days)") +
  scale_fill_manual(values = color_palette) +
  scale_color_manual(values = color_palette) +
  theme_custom +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
    )

# Merge admissions and diagnoses
diagnoses_survival_outcome <- Survival_outcome %>%
  left_join(diagnoses, by = "SUBJECT_ID_COMPOSE") %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL, LONG_TITLE, SEQ_NUM, DIAGNOSES_NUM)

# Plot: Average number of diagnoses per patient by survival length
diagnoses_survival_outcome %>%
  group_by(SURVIVAL) %>%
  summarise(Average_Diagnoses = mean(DIAGNOSES_NUM, na.rm = TRUE), .groups = "drop") %>%
  ggplot(aes(x = SURVIVAL, y = Average_Diagnoses)) +
  geom_line(color = color_palette[10], size = 1.2) +  # Line for trend
  geom_point(color = color_palette[22], fill = "white", shape = 21, size = 2, stroke = 0.5) +  # Dots with outline
  geom_smooth(method = "loess", color = "darkblue", fill = "blue", alpha = 0.2, size = 1, se = TRUE) +  # LOESS smooth trend
  labs(
    title = "Average Number of Diagnoses by Survival Length",
    x = "Survival Length (Days)",
    y = "Average Number of Diagnoses"
  ) +
  scale_x_continuous(limits = c(0, max(diagnoses_survival_outcome$SURVIVAL, na.rm = TRUE)), expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + 
  theme_custom +
  theme(
    panel.grid.major = element_line(color = "grey40", size = 0.5),  # Add gridlines
    panel.grid.minor = element_line(color = "grey95", size = 0.25)
  )

rm(top_diagnoses, diagnoses_admissions_high_priority)

```

Most diagnoses exhibit a central clustering of survival lengths around the median, indicating a similar distribution of survival days for many conditions.

Some outliers indicate that specific diagnoses could have prolonged or extremely short survival outcomes.

Diagnoses like "Unspecified septicemia" and "Coronary atherosclerosis of native coronary artery" appear frequently and may require further exploration for modeling.
Average Number of Diagnoses by Survival Length:

There is an observable upward trend, indicating that a higher survival length corresponds with an increased number of diagnoses.

This suggests a potential relationship where prolonged hospital stays or complex medical conditions (resulting in multiple diagnoses) are associated with extended survival durations.
These insights highlight the importance of including high-priority diagnoses and the number of diagnoses in survival modeling, as they seem to provide significant explanatory value for survival outcomes.

```{r Visualise ICD9 codes over Survival}
diagnoses_transformed_survival <- Survival_outcome %>%
  left_join(diagnoses_transformed, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Pivot the data to long format for plotting
data_long <- diagnoses_transformed_survival %>%
  pivot_longer(
    cols = -c(SUBJECT_ID_COMPOSE, SURVIVAL, SURVIVAL_FLAG), # Replace `SURVIVAL_LENGTH` with your column
    names_to = "ICD9_CODE",
    values_to = "Presence"
  ) %>%
  filter(Presence == 1)  # Keep only rows where ICD9 code is present

# Plot boxplot
# Plot boxplot with faceting by survival flag
ggplot(data_long, aes(x = ICD9_CODE, y = SURVIVAL, fill = as.factor(SURVIVAL_FLAG))) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  coord_flip() +
  scale_fill_manual(values = c("0" = color_palette[6], "1" = color_palette[10]), labels = c("Survived", "Died")) +
  theme_minimal() +
  labs(
    title = "Survival Length by ICD9 Code and Survival Status",
    x = "ICD9 Codes",
    y = "Survival Length (Days)",
    fill = "Survival Status"
  ) +
  facet_wrap(~ SURVIVAL_FLAG, labeller = as_labeller(c(`0` = "Died", `1` = "Survived"))) +
  theme(
    axis.text.y = element_text(size = 7),
    strip.text = element_text(size = 10)  # Adjust facet titles
  )

```

### 4.4.3. Outcome 3: Length of ICU Stay by Diagnoses

```{r Length of ICU Stay by Diagnoses Exploratory Analysis}
# Extract top diagnoses based on frequency
top_diagnoses_los <- diagnoses %>%
  filter(SEQ_NUM == 1) %>%
  count(LONG_TITLE, sort = TRUE) %>%
  mutate(Percentage = n / sum(n) * 100,
         Cumulative_Percentage = cumsum(Percentage)) %>%
  filter(Cumulative_Percentage <= 35) %>%  # Adjust the threshold if necessary
  select(LONG_TITLE)

# Merge with LOS outcome data
diagnoses_los_outcome <- LOS_outcome %>%
  left_join(diagnoses, by = "SUBJECT_ID_COMPOSE") %>% 
  filter(SEQ_NUM == 1, LONG_TITLE %in% top_diagnoses_los$LONG_TITLE)

ggplot(diagnoses_los_outcome, aes(x = LONG_TITLE, y = LOS, fill = LONG_TITLE, color = LONG_TITLE)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.5, fill = "white", shape = 21, size = 2, stroke = 0.5) +
  labs(title = "High-Priority Diagnoses by Length of ICU Stay",
       x = "High-Priority Diagnosis",
       y = "Length of ICU Stay (Days)") +
  scale_fill_manual(values = color_palette) +
  scale_color_manual(values = color_palette) +
  theme_custom +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

diagnoses_los_outcome <- LOS_outcome %>%
  left_join(diagnoses, by = "SUBJECT_ID_COMPOSE") %>%
  select(SUBJECT_ID_COMPOSE, LOS, LONG_TITLE, SEQ_NUM, DIAGNOSES_NUM)

# Plot: Average number of diagnoses per patient by LOS
diagnoses_los_outcome %>%
  group_by(LOS) %>%
  summarise(Average_Diagnoses = mean(DIAGNOSES_NUM, na.rm = TRUE), .groups = "drop") %>%
  ggplot(aes(x = LOS, y = Average_Diagnoses)) +
  geom_line(color = color_palette[10], size = 1.2) +  # Line for trend
  geom_point(color = color_palette[22], fill = "white", shape = 21, size = 2, stroke = 0.5) +  # Dots with outline
  geom_smooth(method = "loess", color = "darkblue", fill = "blue", alpha = 0.2, size = 1, se = TRUE) +  # LOESS smooth trend
  labs(
    title = "Average Number of Diagnoses by Length of ICU Stay",
    x = "Length of ICU Stay (Days)",
    y = "Average Number of Diagnoses"
  ) +
  scale_x_continuous(limits = c(0, max(diagnoses_los_outcome$LOS, na.rm = TRUE)), expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + 
  theme_custom +
  theme(
    panel.grid.major = element_line(color = "grey40", size = 0.5),  # Add gridlines
    panel.grid.minor = element_line(color = "grey95", size = 0.25)
  )

```

This visualization indicates the relationship between specific diagnoses and the corresponding length of ICU stay. Diagnoses such as coronary artery diseases and septicemia are associated with longer stays in the ICU. This suggests that patients with these conditions require more intensive care, aligning with their critical nature.

Conclusion: High-priority diagnoses should be considered in ICU resource planning and can be used as predictors in modeling ICU length of stay.

Trend Observation: There is an increasing trend in the average number of diagnoses as the length of ICU stay increases. This suggests that patients who remain in the ICU longer often present with multiple comorbidities or complications requiring further diagnoses.

Conclusion: The average number of diagnoses can be a key factor when modeling ICU stays, as it reflects the complexity of the patient’s medical condition.

```{r Length of ICU Stay by Diagnose}
diagnoses_transformed_LOS <- LOS_outcome %>%
  left_join(diagnoses_transformed, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID, -ICUSTAY_ID)

# Pivot the data to long format for plotting
data_long <- diagnoses_transformed_LOS %>%
  pivot_longer(
    cols = -c(SUBJECT_ID_COMPOSE, LOS), # Replace `SURVIVAL_LENGTH` with your column
    names_to = "ICD9_CODE",
    values_to = "Presence"
  ) %>%
  filter(Presence == 1)  # Keep only rows where ICD9 code is present

# Plot boxplot
ggplot(data_long, aes(x = ICD9_CODE, y = LOS)) +
  geom_boxplot(outlier.shape = NA, fill = color_palette[4], alpha = 0.7) +
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Survival Length by ICD9 Code",
    x = "ICD9 Codes",
    y = "Survival Length (Days)"
  ) +
  theme(axis.text.y = element_text(size = 7))
```

## 4.4. Exploratory analysis
### 4.4.1. Outcome 1: Death Status by Diagnoses

``` {r Death Status by Diagnoses exploratory analysis}
diagnoses_death_outcome$LONG_TITLE <- droplevels(diagnoses_death_outcome$LONG_TITLE)

result_diagnoses_num <- perform_statistical_tests(diagnoses_death_outcome, "SURVIVAL_FLAG", "DIAGNOSES_NUM", "Diagnoses number")

# Select the ICD9 code columns
predictors <- names(diagnoses_transformed_death_outcome)[!names(diagnoses_transformed_death_outcome) %in% c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG")]

# Initialize an empty list to store results
result <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- perform_statistical_tests(diagnoses_transformed_death_outcome, "SURVIVAL_FLAG", predictor, predictor)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}


# Combine all results into a single data frame
merged_results <- bind_rows(result)

print_table(result_diagnoses_num)
print_table(merged_results)

rm(result_diagnoses_num, results_list, merged_results)
```

All three factors are significant predictors and should be integrated into the modeling framework. Their inclusion will enhance the accuracy and reliability of predictions related to death outcome.

### 4.4.2. Outcome 2: Length of Survival by Diagnoses

```{r Length of Survival by Diagnoses number Exploratory analysis}
diagnoses_survival_outcome <- Survival_outcome %>%
  left_join(diagnoses, by = "SUBJECT_ID_COMPOSE") %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL, SURVIVAL_FLAG, DIAGNOSES_NUM, LONG_TITLE, SEQ_NUM) %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(as.character(SURVIVAL_FLAG)) 
  )

# Create number of diagnoses ranges based on AGE_AT_ADMISSION
diagnoses_survival_numbers <- diagnoses_survival_outcome %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL, SURVIVAL_FLAG, DIAGNOSES_NUM) %>%
  distinct() %>%
  mutate(
    DIAGNOSES_NUM = cut(DIAGNOSES_NUM,
                    breaks = c(0, 1, 3, 5, 10, 40),  # Include 0-1 as the first interval
                    labels = c("1", "1-3", "3-5", "6-10", ">10"),  # Five intervals
                    right = FALSE)  # Include the left boundary in each group
  )

# Generate Kaplan-Meier survival curve by GENDER
fit_diagnoses_num <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ DIAGNOSES_NUM, data = diagnoses_survival_numbers)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_diagnoses_num,
  data = diagnoses_survival_outcome,
  pval = TRUE,  # Display p-value for gender
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Number of Diagnoses",
  title = "Survival Curve by Y",
  palette =  color_palette
)

hr_table_number_diagnoses <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", "DIAGNOSES_NUM", diagnoses_survival_numbers)

print_table(hr_table_number_diagnoses)

rm(diagnoses_survival_outcome, diagnoses_survival_numbers, fit_diagnoses_num, hr_table_number_diagnoses)

```

```{r Length of Survival by Diagnoses Exploratory analysis}

# Define predictors to evaluate
predictors <- c("ICD9_486", "ICD9_41071", "ICD9_41401", "ICD9_4240", "ICD9_4280", "ICD9_5849", "ICD9_0389", "ICD9_4241", "ICD9_430", "ICD9_431", "ICD9_51881", "ICD9_5070")

# Initialize an empty list to store results
result <- list()

diagnoses_transformed_survival  <- diagnoses_transformed_survival  %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

# Loop through each predictor
for (predictor in predictors) {
  
  # Perform the hazard ratio assessment
  test_result <- HR_assessment(
    survival_time = "SURVIVAL",
    event_status = "SURVIVAL_FLAG",
    predictors = predictor,  # Single predictor
    data = diagnoses_transformed_survival
  )
  
  # Append the result to the list
  result[[predictor]] <- test_result
}

# Combine all results into a single data frame
final_result <- do.call(rbind, result)

# Print the final results
print_table(final_result)

rm(final_result, predictors, test_result, param, predictor)

```

The number of diagnoses (grouped as above) may not be a reliable predictor for survival outcomes in this dataset.


### 4.4.3. Outcome 3: Length of ICU Stay by Diagnoses

``` {r Length of ICU Stay by Diagnoses Data Exploratory Analysis}
diagnoses_LOS_numbers <- diagnoses_los_outcome %>%
  select(SUBJECT_ID_COMPOSE, LOS, DIAGNOSES_NUM) %>%
  distinct() %>%
  mutate(
    DIAGNOSES_NUM = cut(DIAGNOSES_NUM,
                    breaks = c(0, 1, 3, 5, 10, 40),  # Include 0-1 as the first interval
                    labels = c("1", "1-3", "3-5", "6-10", ">10"),  # Five intervals
                    right = FALSE)  # Include the left boundary in each group
  )

result_diagnoses_num <- analyze_predictor_LOS(diagnoses_LOS_numbers, predictor = "DIAGNOSES_NUM", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")

print_table(result_diagnoses_num)

rm(result_diagnoses_num, diagnosis_LOS_numbers, diagnoses_los_outcome)
```

Higher numbers of diagnoses (6-10 and >10) are predictive of longer ICU stays, as indicated by statistically significant results.

```{r Length of LOS by Diagnoses Exploratory analysis}

# Define predictors to evaluate
predictors <- c("ICD9_486", "ICD9_41071", "ICD9_41401", "ICD9_4240", "ICD9_4280", "ICD9_5849", "ICD9_0389", "ICD9_4241", "ICD9_430", "ICD9_431", "ICD9_51881", "ICD9_5070")

# Initialize an empty list to store results
results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform assessment for the current predictor
  result <- analyze_predictor_LOS(data = diagnoses_transformed_LOS, predictor = predictor, LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
  
  # Append the result to the list
  results[[predictor]] <- result
}

# Combine all results into a single data frame
table <- do.call(rbind, lapply(names(results), function(predictor) {
  cbind(Predictor = predictor, results[[predictor]])
}))

# Convert to data frame for better formatting
table <- as.data.frame(table)

# Print the final HR table
print_table(table)

rm(table, results, predictors, predictor)

```

# 5. Isolations Data
## 5.1. Read data

``` {r read data isolations}
isolations <- read.csv("../data/raw/cleaned/CALLOUT_clean.csv", stringsAsFactors = TRUE) %>%
  mutate(across(where(is.character), as.factor))  %>%
  filter(SUBJECT_ID %in% subject_ids_adults) %>%
  select(-REQUEST_TELE, -REQUEST_RESP) %>%
  mutate(SUBJECT_ID = as.factor(SUBJECT_ID),
         REQUEST_CDIFF = as.factor(REQUEST_CDIFF),
         REQUEST_MRSA = as.factor(REQUEST_MRSA),
         REQUEST_VRE = as.factor(REQUEST_VRE))

skimr::skim(isolations %>%
              select(-SUBJECT_ID, -HADM_ID, -ROW_ID))
```


## 5.2.   Descriptive Statistics
### 5.2.1. Descriptive statistics for categorical variables (Isolations Data)

```{r descriptive statistics for categorical vars (Isolations Data)}
# Clean and summarize the categorical data for all factor variables
isolations %>%
  select(-SUBJECT_ID, -SUBJECT_ID_COMPOSE, -OUTCOMETIME) %>%
  select(where(is.factor)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  group_by(Variable, Value) %>%
  summarise(n = n(), .groups = 'drop') %>%
  group_by(Variable) %>%
  mutate(`No data` = sum(is.na(Value)),
         `% by group` = (n / sum(n)) * 100) %>%
  ungroup() %>%
  select(Variable, Value, n, `% by group`, `No data`) %>%
  arrange(Variable, Value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

## 5.3. Visualisation Analysis by Outcome
### 5.3.1. Outcome 1: Death Status by Isolations Data

```{r Death Status by Isolations Data}
isolations_death_outcome <- Death_status_outcome %>%
  left_join(isolations, by = "SUBJECT_ID_COMPOSE") %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, REQUEST_VRE, REQUEST_MRSA, REQUEST_CDIFF) %>%
  filter(!is.na(REQUEST_VRE) & !is.na(REQUEST_MRSA) & !is.na(REQUEST_CDIFF))

# Reshape the data to long format
data_long <- isolations_death_outcome %>%
  pivot_longer(cols = c(REQUEST_VRE, REQUEST_MRSA, REQUEST_CDIFF), 
               names_to = "Request_Type", 
               values_to = "Flag") %>%
  filter(!is.na(Flag))  # Remove rows where Flag is NA


# Ensure Flag is a binary column (0 or 1)
data_long$Flag <- as.integer(data_long$Flag)

# Group by SURVIVAL_FLAG and Request_Type, then calculate counts
count_data <- data_long %>%
  group_by(SURVIVAL_FLAG, Request_Type) %>%
  summarise(Count = sum(Flag == 1), .groups = "drop")  # Count where Flag == 1 (bacteria found)

# Plot the data
ggplot(count_data, aes(x = Request_Type, y = Count, fill = factor(SURVIVAL_FLAG))) +
  geom_bar(stat = "identity", position = "dodge2") +
  labs(title = "Count of Bacteria Requests by Death Status",
       x = "Request Type",
       y = "Count",
       fill = "Survival Status") +
  scale_fill_manual(values = c(color_palette[7], color_palette[12]), labels = c("Survived", "Died")) +
  geom_text(aes(label = Count), vjust = -0.5, position = position_dodge(0.9), size = 3.5) +  # Add text labels
  theme_custom +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate the x-axis labels for better readability

rm(count_data, data_long)
```

### 5.3.2. Outcome 2: Length of Survival by Isolations Data

```{r Length of Survival by Isolations Data}

isolations_survival_outcome <- Survival_outcome %>%
  left_join(isolations, by = "SUBJECT_ID_COMPOSE") %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, SURVIVAL, REQUEST_VRE, REQUEST_MRSA, REQUEST_CDIFF) %>%
  filter(!is.na(REQUEST_VRE) & !is.na(REQUEST_MRSA) & !is.na(REQUEST_CDIFF))

# Reshape the data to long format for better visualization
isolations_long <- isolations_survival_outcome %>%
  pivot_longer(cols = c(REQUEST_VRE, REQUEST_MRSA, REQUEST_CDIFF), 
               names_to = "Isolation_Type", 
               values_to = "Isolation_Flag") %>%
  filter(!is.na(Isolation_Flag))  # Remove rows with missing values for Isolation_Flag

# Plot: Boxplot of Survival Time by Isolation Flag
ggplot(isolations_long, aes(x = factor(Isolation_Flag), y = SURVIVAL, fill = factor(Isolation_Flag))) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~Isolation_Type) + 
  labs(title = "Survival Time by Bacterial Infection Requests (Isolation Flags)",
       x = "Isolation Flag (0 = No, 1 = Yes)", y = "Survival Time (Days)") +
  scale_fill_manual(values = c(color_palette[6], color_palette[10]), labels = c("No Infection", "Infection Detected")) +
  theme_custom +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

rm(isolations_long)

```

### 5.3.3. Outcome 3: Length of ICU Stay by Isolations Data

``` {r Length of ICU Stay by Isolations Data}
isolations_los_outcome <- LOS_outcome %>%
  left_join(isolations, by = "SUBJECT_ID_COMPOSE") %>%
  select(SUBJECT_ID_COMPOSE, LOS, REQUEST_VRE, REQUEST_MRSA, REQUEST_CDIFF) %>%
  filter(!is.na(REQUEST_VRE) & !is.na(REQUEST_MRSA) & !is.na(REQUEST_CDIFF))


# Reshape the data to long format for better visualization
isolations_long <- isolations_los_outcome %>%
  pivot_longer(cols = c(REQUEST_VRE, REQUEST_MRSA, REQUEST_CDIFF), 
               names_to = "Isolation_Type", 
               values_to = "Isolation_Flag") %>%
  filter(!is.na(Isolation_Flag))  # Remove rows with missing values for Isolation_Flag

# Plot: Boxplot of Survival Time by Isolation Flag
ggplot(isolations_long, aes(x = factor(Isolation_Flag), y = LOS, fill = factor(Isolation_Flag))) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~Isolation_Type) + 
  labs(title = "Survival Time by Bacterial Infection Requests (Isolation Flags)",
       x = "Isolation Flag (0 = No, 1 = Yes)", y = "Survival Time (Days)") +
  scale_fill_manual(values = c(color_palette[9], color_palette[15]), labels = c("No Infection", "Infection Detected")) +
  theme_custom +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

rm(isolations_long)
```

## 5.4. Exploratory analysis
### 5.4.1. Outcome 1: Death Status by Isolations Data

```{r Death Status by Isolations Data Exploratory Analysis}

result_CDIFF <- perform_statistical_tests(isolations_death_outcome, "SURVIVAL_FLAG", "REQUEST_CDIFF", "CDIFF")
result_MRSA <- perform_statistical_tests(isolations_death_outcome, "SURVIVAL_FLAG", "REQUEST_MRSA", "MRSA")
result_VRE <- perform_statistical_tests(isolations_death_outcome, "SURVIVAL_FLAG", "REQUEST_VRE", "VRE")

# Merge the results
merged_results <- bind_rows(result_CDIFF, result_MRSA, result_VRE)

print_table(merged_results)

rm(result_CDIFF, result_MRSA, result_VRE, merged_results)

```

CDIFF, MRSA, and VRE will be considered as key predictors in death outcome models.

### 5.4.2. Outcome 2: Length of Survival by Admissions Data

```{r Length of Survival by Isolations Data exploratory analysis}

# Fit Kaplan-Meier model
fit_CDIFF <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ REQUEST_CDIFF, data = isolations_survival_outcome)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_CDIFF,
  data = isolations_survival_outcome,
  pval = TRUE,  # Display p-value
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Religion",
  title = "Survival Curve by Religion",
  palette = color_palette
)

# Fit Kaplan-Meier model
fit_MRSA <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ REQUEST_MRSA, data = isolations_survival_outcome)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_MRSA,
  data = isolations_survival_outcome,
  pval = TRUE,  # Display p-value
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Marital Status",
  title = "Survival Curve by Marital Status",
  palette = color_palette
)

# Fit Kaplan-Meier model
fit_VRE <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ REQUEST_VRE, data = isolations_survival_outcome)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_VRE,
  data = isolations_survival_outcome,
  pval = TRUE,  # Display p-value
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Ethnicity",
  title = "Survival Curve by Ethnicity",
  palette = color_palette
)

hr_table <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", c("REQUEST_CDIFF", "REQUEST_MRSA", "REQUEST_VRE"), isolations_survival_outcome)

print_table(hr_table)

rm(isolations_survival_outcome, hr_table, fit_CDIFF, fit_MRSA, fit_VRE)

```

Increased Risk: Significant risks are observed for Clostridium Difficile (CDIFF) and Vancomycin-Resistant Enterococci (VRE), which both increase the risk of death.

In summary, REQUEST_CDIFF, and REQUEST_VRE are strong candidates for inclusion in future models, while REQUEST_MRSA can be excluded or investigated further for possible significance with a larger dataset.

### 5.4.3. Outcome 3: Length of ICU Stay by Isolations Data

``` {r Length of ICU Stay by isolations Data exploratary analysis}
  
result_CDIFF <- analyze_predictor_LOS(isolations_los_outcome, predictor = "REQUEST_CDIFF", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
result_MRSA <- analyze_predictor_LOS(isolations_los_outcome, predictor = "REQUEST_MRSA", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
result_VRE <- analyze_predictor_LOS(isolations_los_outcome, predictor = "REQUEST_VRE", LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")

# Merge the results
merged_results <- bind_rows(result_CDIFF, result_MRSA, result_VRE)

print_table(merged_results)

rm(isolations, isolations_los_outcome, merged_results, result_CDIFF, result_MRSA, result_VRE)
```

REQUEST_CDIFF, REQUEST_MRSA, and REQUEST_VRE as strong predictors of LOS.

# 6. Prescriptions Data
# 6.1. Read data

``` {r read data prescriptions}
prescriptions <- read.csv("../data/raw/cleaned/PRESCRIPTIONS_clean.csv", stringsAsFactors = TRUE) %>%
  mutate(across(where(is.character), as.factor))  %>%
  filter(SUBJECT_ID %in% subject_ids_adults) %>%
  mutate(SUBJECT_ID = as.factor(SUBJECT_ID),
         ICUSTAY_ID = as.factor(ICUSTAY_ID),
         ATC_ID = as.factor(ATC_ID),
         STARTDATE = as.Date(STARTDATE),
         ENDDATE = as.Date(ENDDATE)) %>%
  select(-DRUG, -NDC, -DOSE_VAL_RX, -DOSE_UNIT_RX, -RXCUI, -COMBINED_INFO, -ATC_TYPE) 

skimr::skim(prescriptions %>%
              select(-SUBJECT_ID, -HADM_ID, -SUBJECT_ID_COMPOSE, -ICUSTAY_ID))
```
## 6.2. Desriptive statistics

### 6.2.1. Descriptive statistics for categorical variables Prescriptions data)

```{r descriptive statistics prescriptions}
# Clean and summarize the categorical data for all factor variables
prescriptions %>%
  select(-SUBJECT_ID, -HADM_ID, -SUBJECT_ID_COMPOSE, -ICUSTAY_ID, -ATC_ID) %>%
  select(where(is.factor)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  filter(!is.na(Value)) %>%
  group_by(Variable, Value) %>%
  summarise(n = n(), .groups = 'drop') %>%
  group_by(Variable) %>%
  mutate(`No data` = sum(is.na(Value)),
         `% by group` = (n / sum(n)) * 100) %>%
  ungroup() %>%
  filter(`% by group` > 0.5) %>%
  select(Variable, Value, n, `% by group`, `No data`) %>%
  arrange(Variable, Value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

```{r prescriptions data transformation}
unique_prescriptions <- prescriptions %>%
  filter(DRUG_TYPE == "MAIN") %>%
  count(ATC_ID) %>%
  filter(n > 1000) %>%
  filter(ATC_ID %in% c("J01CA", "J01DD", "J01DH", "J01GB", "J02AC",
    "B01AA", "B01AB", "B01AC",
    "C01AA", "C01CA", "C09AA", "C09CA",
    "N02AA", "N05CD", "N01AH",
    "L04AD", "L01EG",
    "R03AC", "R03DC",
    "H02AA", "H01AA",
    "B05BB", "B05XA",
    "A02BA", "A02BC",
    "D01AC")) %>%
  pull(ATC_ID) 

# Filter and select relevant columns
prescriptions_transformed <- prescriptions %>%
  filter(ATC_ID %in% unique_prescriptions) %>%
  filter(DRUG_TYPE == "MAIN") %>%
  select(-SUBJECT_ID, -HADM_ID, -ICUSTAY_ID, -ATC_NAME, -DRUG_NAME_GENERIC, -DRUG_TYPE, -ROUTE, -STARTDATE, -ENDDATE)  %>%
  distinct() %>%
  mutate(PRESENT = 1) %>%  # Add flag for presence
# Pivot longer and one-hot encode ICD9_CODE
  mutate(PRESENT = 1) %>%  # Add flag for presence
  pivot_wider(
    names_from = ATC_ID,
    values_from = PRESENT,
    values_fill = list(PRESENT = NA)
  ) %>%
  rename_with(~ paste0(.), -SUBJECT_ID_COMPOSE)

prescriptions_transformed <- prescriptions_transformed %>%
  group_by(SUBJECT_ID_COMPOSE) %>%
  summarise(
    across(
      everything(), 
      ~ if (all(is.na(.))) NA else na.omit(.)[1], # Keep the first non-NA value
      .names = "{.col}"
    )
  ) %>%
  ungroup() %>%
  mutate(
    across(everything(), ~ replace_na(., 0)),
        across(where(is.numeric), as.factor)
  ) 

```

Chosen ATC Codes for ICU Survival Model:
Antibiotics and Antimicrobials: Critical in treating infections in ICU patients.

- J01CA: Penicillins with extended spectrum.
- J01DD: Third-generation cephalosporins.
- J01DH: Carbapenems.
- J01GB: Aminoglycosides.
- J02AC: Triazole antifungals (for fungal infections).

Anticoagulants and Coagulants: Common for preventing or managing thrombosis.

- B01AA: Vitamin K antagonists.
- B01AB: Heparins.
- B01AC: Platelet aggregation inhibitors.

Cardiovascular Agents: For heart function stabilization in critically ill patients.

- C01AA: Cardiac glycosides.
- C01CA: Adrenergic and dopaminergic agents.
- C09AA: ACE inhibitors.
- C09CA: Angiotensin II antagonists.

Sedatives and Analgesics: For pain management and sedation in ICU settings.

- N02AA: Opioid analgesics.
- N05CD: Benzodiazepine derivatives (sedation).
- N01AH: General anesthetics.

Immunosuppressants: Critical in managing sepsis or post-transplant patients.

- L04AD: Tumor necrosis factor-alpha inhibitors.
- L01EG: Protein kinase inhibitors (e.g., for cancer patients).

Respiratory Agents: Essential for patients requiring ventilation support.
- R03AC: Selective beta-2-adrenoreceptor agonists.
- R03DC: Leukotriene receptor antagonists.

Steroids and Hormonal Agents: For inflammation control and adrenal insufficiency.
- H02AA: Corticosteroids for systemic use.
- H01AA: Pituitary and hypothalamic hormones.

Electrolytes and Infusions: To stabilize critically ill patients.
- B05BB: Solutions affecting electrolyte balance.
- B05XA: Blood substitutes and perfusion solutions.

Gastrointestinal Agents: For managing ICU-related stress ulcers and reflux.

- A02BA: H2 receptor antagonists.
- A02BC: Proton pump inhibitors.

Antiseptics and Antifungals: Used to prevent and treat secondary infections.

- D01AC: Antifungals for systemic use.

## 6.3. Visualisation Analysis by Outcome
### 6.3.1. Outcome 1: Death Status by Prescripions Data

```{r Death Status by Prescripions Data}

# Assuming Death_status_outcome contains death information and prescriptions has drug data
prescriptions_death_outcome <- Death_status_outcome %>%
  left_join(prescriptions, by = c("SUBJECT_ID_COMPOSE", "SUBJECT_ID")) %>% 
  distinct() %>%
  select("SUBJECT_ID_COMPOSE", ATC_NAME, DRUG_TYPE, DRUG_NAME_GENERIC, SURVIVAL_FLAG)

prescriptions_death_outcome %>%
  group_by(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG) %>%  
  summarise(
    num_drugs = n_distinct(DRUG_NAME_GENERIC), 
    .groups = "drop"
  ) %>%
  group_by(SURVIVAL_FLAG) %>%                     
  summarise(
    avg_prescriptions_per_patient = mean(num_drugs, na.rm = TRUE), 
    total_patients = n(),                                
    .groups = "drop"
  ) %>%
ggplot(aes(x = factor(SURVIVAL_FLAG), y = avg_prescriptions_per_patient, fill = factor(SURVIVAL_FLAG))) +
  geom_bar(stat = "identity", width = 0.6) +
  geom_text(
    aes(label = sprintf("%.2f", avg_prescriptions_per_patient)),
    position = position_stack(vjust = 0.5),
    size = 5                                
  ) +
  labs(
    title = "Average Number of Drugs per Patient by Survival Status",
    x = "Survival Status",
    y = "Average Number of Drugs",
    fill = "Survival Status"
  ) +
 scale_fill_manual(
    values = sample(color_palette, size = length(unique(prescriptions_death_outcome$SURVIVAL_FLAG)), replace = FALSE),
    labels = c("0" = "Not Dead", "1" = "Dead")
    ) +
  theme_custom +                                                  # Apply custom theme
  theme(
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Calculate mean number of drugs by DRUG_TYPE and Survival Status
prescriptions_death_outcome %>%
  group_by(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, DRUG_TYPE) %>%
  summarise(
    num_drugs = n_distinct(DRUG_NAME_GENERIC),  # Count distinct drugs per patient by drug type
    .groups = "drop"
  ) %>%
  group_by(DRUG_TYPE, SURVIVAL_FLAG) %>%
  summarise(
    avg_prescriptions_per_patient = mean(num_drugs, na.rm = TRUE),  # Average drugs per drug type
    total_patients = n(),                                  # Count total patients
    .groups = "drop"
  ) %>%
ggplot(aes(x = DRUG_TYPE, y = avg_prescriptions_per_patient, fill = factor(SURVIVAL_FLAG))) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.6) +
  geom_text(
    aes(label = sprintf("%.2f", avg_prescriptions_per_patient)),  # Add average drugs labels
    position = position_dodge(width = 0.8),               # Place text above bars
    vjust = -0.5,                                         # Adjust vertical position
    size = 4                                              # Adjust text size
  ) +
  labs(
    title = "Average Number of Drugs by Drug Type and Survival Status",
    x = "Drug Type",
    y = "Average Number of Drugs",
    fill = "Survival Status"
  ) +
   scale_fill_manual(
    values = sample(color_palette, size = length(unique(prescriptions_death_outcome$SURVIVAL_FLAG)), replace = FALSE),
    labels = c("0" = "Not Dead", "1" = "Dead")
    ) +
  theme_custom +                                          # Apply custom theme
  theme(
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)     # Rotate x-axis labels for better readability
  )

# Filter for DRUG_TYPE == "MAIN" and find the most common drugs by survival flag
top_common_drugs <- prescriptions_death_outcome %>%
  filter(DRUG_TYPE == "MAIN") %>%                # Filter rows where DRUG_TYPE is "MAIN"
  group_by(SURVIVAL_FLAG, DRUG_NAME_GENERIC) %>%
  summarise(count = n(), .groups = "drop") %>%   # Count occurrences of each drug
  arrange(SURVIVAL_FLAG, desc(count)) %>%        # Sort by survival flag and count (descending)
  group_by(SURVIVAL_FLAG) %>%
  slice_head(n = 20) %>%                          # Select the top 5 most common drugs for each survival flag
  ungroup()

# Visualize the top common drugs as a grouped bar plot
ggplot(top_common_drugs, aes(x = reorder(DRUG_NAME_GENERIC, -count), y = count, fill = factor(SURVIVAL_FLAG))) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.6) +
  labs(
    title = "Top 5 Most Common Main Drugs by Survival Flag",
    x = "Drug Name (Generic)",
    y = "Count",
    fill = "Survival Status"
  ) +
   scale_fill_manual(
    values = sample(color_palette, size = length(unique(prescriptions_death_outcome$SURVIVAL_FLAG)), replace = FALSE),
    labels = c("0" = "Not Dead", "1" = "Dead")
    ) +
  coord_flip() +
  theme_custom +
  theme(
    legend.position = "top",
    axis.text.x = element_text(angle = 45, hjust = 1)     # Rotate x-axis labels for better readability
  )

# Identify top ATC names by frequency
top_atc_names <- prescriptions_death_outcome %>%
  group_by(ATC_NAME) %>%
  summarise(count = n(), .groups = "drop") %>%         # Count occurrences of each ATC name
  arrange(desc(count)) %>%                            # Sort by descending frequency
  slice_head(n = 10)                                  # Select top 10 ATC names

# Visualize top ATC names
ggplot(top_atc_names, aes(x = reorder(ATC_NAME, -count), y = count)) +
  geom_bar(stat = "identity", fill = "pink", width = 0.7) +
  geom_text(aes(label = count), hjust = -0.5, size = 4) +
  labs(
    title = "Top 10 ATC Names",
    x = "ATC Name",
    y = "Frequency"
  ) +
  coord_flip() +
  theme_custom +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
  )

rm(top_common_drugs, top_atc_names)

```

```{r Visualise ATC codes over Death Status}
prescriptions_transformed_death_outcome <- Death_status_outcome %>%
  left_join(prescriptions_transformed, by = c("SUBJECT_ID_COMPOSE")) %>%
  select(-SUBJECT_ID)

# Pivot the data to long format and filter for presence (1)
atc_summary <- prescriptions_transformed_death_outcome %>%
  pivot_longer(
    cols = -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG),  # Pivot ICD9 code columns
    names_to = "ATC",
    values_to = "Presence"
  ) %>%
  filter(Presence == 1) %>%  # Keep only rows where ICD9 code is present
  group_by(ATC, SURVIVAL_FLAG) %>%  # Group by ICD9 code and survival flag
  summarise(Count = n_distinct(SUBJECT_ID_COMPOSE), .groups = "drop") %>% # Count unique subjects
  arrange(desc(Count))  
  
# Plot for Survival Flag = 0 (Died)
ggplot(atc_summary %>% filter(SURVIVAL_FLAG == 0), aes(x = ATC, y = Count, fill = as.factor(SURVIVAL_FLAG))) +
  geom_bar(stat = "identity", position = "dodge2", color = "black") +
  scale_fill_manual(values = c("0" = color_palette[12]), name = "Survival Status") +
  theme_custom +
  labs(
    title = "Number of Subjects per ICD9 Code - Died",
    x = "ATC Code",
    y = "Number of Subjects"
  ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size= 3 )) +
  guides(fill = "none")  # Remove redundant legend for single-status plot

# Plot for Survival Flag = 1 (Survived)
ggplot(atc_summary %>% filter(SURVIVAL_FLAG == 1), aes(x = ATC, y = Count, fill = as.factor(SURVIVAL_FLAG))) +
  geom_bar(stat = "identity", position = "dodge2", color = "black") +
  scale_fill_manual(values = c("1" = color_palette[1]), name = "Survival Status") +
  theme_custom +
  labs(
    title = "Number of Subjects per ICD9 Code - Survived",
    x = "ATC Code",
    y = "Number of Subjects"
  ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size= 3 )) +
  guides(fill = "none")  # Remove redundant legend for single-status plot

```

### 6.3.2. Outcome 2: Length of Survival by Prescriptions Data

```{r Length of Survival by Prescriptions Data}
prescriptions_survival_outcome <- Survival_outcome %>%
  left_join(prescriptions, by = c("SUBJECT_ID", "SUBJECT_ID_COMPOSE")) %>%
  distinct()

prescriptions_survival_outcome %>%
  group_by(SUBJECT_ID_COMPOSE, SURVIVAL) %>%
  summarise(
    num_drugs = n_distinct(DRUG_NAME_GENERIC),  # Count distinct drugs per patient
    .groups = "drop"
  ) %>%
  ggplot(aes(x = num_drugs)) +
  geom_density(fill = color_palette[8], alpha = 0.6) +
  labs(
    title = "Density of Number of Drugs by Survival (Days)",
    x = "Number of Drugs",
    y = "Density"
  ) +
  theme_custom +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Boxplot: Survival distribution by drug type
prescriptions_survival_outcome %>%
  ggplot(aes(x = DRUG_TYPE, y = SURVIVAL, fill = DRUG_TYPE)) +
  geom_boxplot(outlier.color = "black") +
  labs(
    title = "Survival Distribution by Drug Type",
    x = "Drug Type",
    y = "Survival (Days)"
  ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(prescriptions_survival_outcome$DRUG_TYPE)), replace = FALSE)
    ) +
  theme_custom +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Filter for DRUG_TYPE == "MAIN" and find the most common drugs
top_common_drugs <- prescriptions_survival_outcome %>%
  filter(DRUG_TYPE == "MAIN") %>%               
  group_by(DRUG_NAME_GENERIC) %>%
  summarise(count = n(), .groups = "drop") %>%    # Count occurrences of each drug
  arrange(desc(count)) %>%                       # Sort by descending frequency
  slice_head(n = 20)                             # Select the top 20 most common drugs

# Boxplot: Survival distribution by top generic names
prescriptions_survival_outcome %>%
  filter(DRUG_NAME_GENERIC %in% unique(top_common_drugs$DRUG_NAME_GENERIC)) %>%
  ggplot(aes(x = reorder(DRUG_NAME_GENERIC, SURVIVAL), y = SURVIVAL, fill = DRUG_NAME_GENERIC)) +
  geom_boxplot(outlier.color = "black") +
  coord_flip() +
  labs(
    title = "Survival Distribution by Top Generic Names",
    x = "Generic Name",
    y = "Survival (Days)"
  ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(top_common_drugs$DRUG_NAME_GENERIC)), replace = FALSE)
  ) +
  theme_custom +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5, face = "bold")
  )
```

```{r Visualise ATC codes over Survival}
prescriptions_transformed_survival <- Survival_outcome %>%
  left_join(prescriptions_transformed, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Get the list of ATC columns (exclude non-ATC columns)
atc_columns <- names(prescriptions_transformed_survival) %>%
  setdiff(c("SUBJECT_ID_COMPOSE", "SURVIVAL", "SURVIVAL_FLAG"))

# Initialize a list to store plots
atc_plots <- list()

# Loop through each ATC column and generate a plot
for (atc in atc_columns) {
  # Dynamically filter and prepare data for the current ATC column
  plot_data <- prescriptions_transformed_survival %>%
    select(SURVIVAL_FLAG, SURVIVAL, all_of(atc)) %>%
    rename(ATC_PRESENCE = !!atc) %>%
    mutate(ATC_PRESENCE = as.factor(ATC_PRESENCE)) %>%  # Ensure it's a factor
    filter(!is.na(ATC_PRESENCE))  # Remove rows with NA in the ATC column
  
  # Generate the plot for the current ATC column
  atc_plots[[atc]] <- ggplot(plot_data, aes(x = ATC_PRESENCE, y = SURVIVAL, fill = as.factor(SURVIVAL_FLAG))) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    scale_fill_manual(values = c("0" = color_palette[6], "1" = color_palette[10]), labels = c("Survived", "Died")) +
    theme_minimal() +
    labs(
      title = paste("Survival Length by", atc),
      x = paste(atc, "Presence"),
      y = "Survival Length (Days)",
      fill = "Survival Status"
    ) +
    theme(
      axis.text.x = element_text(size = 10),
      title = element_text(size =10),
      legend.position = "right"
    )
}

# Define the number of plots per page
plots_per_page <- 4

# Split plots into chunks of 4
plot_chunks <- split(atc_plots, ceiling(seq_along(atc_plots) / plots_per_page))

# Iterate over each chunk and display them
for (chunk in plot_chunks) {
  grid.arrange(
    grobs = chunk,
    ncol = 2,  # Number of columns in the grid
    nrow = 2   # Number of rows in the grid
  )
}

```

### 6.3.3. Outcome 3: Length of ICU Stay by Prescriptions Data

```{r Length of ICU Stay by Prescriptions Data}
prescriptions_los_outcome <- LOS_outcome %>%
  left_join(prescriptions, by = c("SUBJECT_ID_COMPOSE", "ICUSTAY_ID", "SUBJECT_ID")) %>%
  distinct()

# Density plot: Number of drugs vs. LOS
prescriptions_los_outcome %>%
  group_by(SUBJECT_ID_COMPOSE, LOS) %>%
  summarise(
    num_drugs = n_distinct(DRUG_NAME_GENERIC),  # Count distinct drugs per patient
    .groups = "drop"
  ) %>%
  ggplot(aes(x = num_drugs)) +
  geom_density(fill = color_palette[8], alpha = 0.6) +
  labs(
    title = "Density of Number of Drugs by LOS (Days)",
    x = "Number of Drugs",
    y = "Density"
  ) +
  theme_custom +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Boxplot: LOS distribution by drug type
prescriptions_los_outcome %>%
  ggplot(aes(x = DRUG_TYPE, y = LOS, fill = DRUG_TYPE)) +
  geom_boxplot(outlier.color = "black") +
  labs(
    title = "LOS Distribution by Drug Type",
    x = "Drug Type",
    y = "LOS (Days)"
  ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(prescriptions_los_outcome$DRUG_TYPE)), replace = FALSE)
  ) +
  theme_custom +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Filter for DRUG_TYPE == "MAIN" and find the most common drugs
top_common_drugs <- prescriptions_los_outcome %>%
  filter(DRUG_TYPE == "MAIN") %>%               
  group_by(DRUG_NAME_GENERIC) %>%
  summarise(count = n(), .groups = "drop") %>%    # Count occurrences of each drug
  arrange(desc(count)) %>%                       # Sort by descending frequency
  slice_head(n = 20)                             # Select the top 20 most common drugs

# Boxplot: LOS distribution by top generic names
prescriptions_los_outcome %>%
  filter(DRUG_NAME_GENERIC %in% unique(top_common_drugs$DRUG_NAME_GENERIC)) %>%
  ggplot(aes(x = reorder(DRUG_NAME_GENERIC, LOS), y = LOS, fill = DRUG_NAME_GENERIC)) +
  geom_boxplot(outlier.color = "black") +
  coord_flip() +
  labs(
    title = "LOS Distribution by Top Generic Names",
    x = "Generic Name",
    y = "LOS (Days)"
  ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(top_common_drugs$DRUG_NAME_GENERIC)), replace = FALSE)
  ) +
  theme_custom +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Identify top ATC names by frequency
top_atc_names <- prescriptions_los_outcome %>%
  group_by(ATC_NAME) %>%
  summarise(count = n(), .groups = "drop") %>%
  arrange(desc(count)) %>%
  slice_head(n = 10)  # Select the top 10 ATC names

# Boxplot: LOS distribution by top ATC names
prescriptions_los_outcome %>%
  filter(ATC_NAME %in% unique(top_atc_names$ATC_NAME)) %>%
  ggplot(aes(x = reorder(ATC_NAME, LOS), y = LOS, fill = ATC_NAME)) +
  geom_boxplot(outlier.color = "black") +
  coord_flip() +
  labs(
    title = "LOS Distribution by Top ATC Names",
    x = "ATC Name",
    y = "LOS (Days)"
  ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(top_atc_names$ATC_NAME)), replace = FALSE)
  ) +
  theme_custom +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  )
```

```{r Visualise ATC code over Survival}
prescriptions_transformed_los <- LOS_outcome %>%
  left_join(prescriptions_transformed, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Pivot the data to long format for plotting
data_long <- prescriptions_transformed_los %>%
  pivot_longer(
    cols = -c(SUBJECT_ID_COMPOSE, LOS), # Replace `SURVIVAL_LENGTH` with your column
    names_to = "ATC",
    values_to = "Presence"
  ) %>%
  filter(Presence == 1)  # Keep only rows where ICD9 code is present

# Plot boxplot
ggplot(data_long, aes(x = ATC, y = LOS)) +
  geom_boxplot(outlier.shape = NA, fill = color_palette[4], alpha = 0.7) +
  coord_flip() +
  theme_minimal() +
  labs(
    title = "LOS by ATC Code",
    x = "ATC Codes",
    y = "LOS (Days)"
  ) +
  theme(axis.text.y = element_text(size = 7))
```

## 6.4. Exploratory analysis
### 6.4.1. Outcome 1: Death Status by Prescriptions Data

```{r Death Status by Prescriptions Data Exploratory Analysis}
prescriptions_number <- prescriptions_death_outcome %>%
  group_by(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG) %>%
  summarise(
    PRESCRIPTIONS_NUM = n(),  # Count total prescriptions per patient
    .groups = "drop"
  )

result_prescriptions_number <- perform_statistical_tests(prescriptions_number, "SURVIVAL_FLAG", "PRESCRIPTIONS_NUM", "Prescription number")

predictors <- names(prescriptions_transformed_death_outcome)[!names(prescriptions_transformed_death_outcome) %in% c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG")]

# Initialize an empty list to store results
result <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- perform_statistical_tests(prescriptions_transformed_death_outcome, "SURVIVAL_FLAG", predictor, predictor)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}


# Combine all results into a single data frame
merged_results <- bind_rows(result)

print_table(merged_results)
print_table(result_prescriptions_number)

rm(result_prescriptions_number, result_ATC, result_generic_name)
```

### 6.4.2. Outcome 2: Length of Survival by Prescriptions

```{r Length of Survival by Prescriptions Exploratory analysis}
# Merge survival outcome with prescriptions and create DRUGS_NUM
prescriptions_survival_outcome <- Survival_outcome %>%
  left_join(prescriptions, by = "SUBJECT_ID_COMPOSE") %>%
  group_by(SUBJECT_ID_COMPOSE, SURVIVAL, SURVIVAL_FLAG) %>%
  summarise(
    DRUGS_NUM = n_distinct(DRUG_NAME_GENERIC),  # Count distinct drugs prescribed for each patient
    .groups = "drop"
  ) %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(as.character(SURVIVAL_FLAG))  # Ensure SURVIVAL_FLAG is numeric
  )

# Create number of drugs ranges
prescriptions_survival_numbers <- prescriptions_survival_outcome %>%
  distinct() %>%
  mutate(
    prescriptions_NUM = cut(DRUGS_NUM,
                    breaks = c(0, 1, 3, 10, 20, 30, Inf),  # Include 0-1 as the first interval
                    labels = c("1", "1-3", "3-10", "10-20", "20-30", ">30"),  # Five intervals
                    right = FALSE)  # Include the left boundary in each group
  )

# Generate Kaplan-Meier survival curve by number of drugs
fit_prescriptions_num <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ prescriptions_NUM, data = prescriptions_survival_numbers)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_prescriptions_num,
  data = prescriptions_survival_numbers,
  pval = TRUE,  # Display p-value for drug number
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Number of Drugs",
  title = "Survival Curve by Number of Drugs",
  palette = color_palette
)

# Perform Hazard Ratio (HR) assessment
hr_table_number_drugs <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", "prescriptions_NUM", prescriptions_survival_numbers)

print_table(hr_table_number_drugs)

# Remove intermediate objects to clean up
rm(prescriptions_survival_outcome, prescriptions_survival_numbers, fit_prescriptions_num, hr_table_number_drugs)

```

PRESCRIPTIONS_NUM should be included as a predictor in future modeling.

Significant Risk: All intervals show highly significant hazard ratios (HR) with p < 0.0001, indicating it is strongly associated with survival outcomes.

```{r Length of Survival by Pescriptionss Exploratory analysis}

# Define predictors to evaluate
predictors <- c("J01CA", "J01DD", "J01DH", "J01GB", "J02AC",
    "B01AA", "B01AB", "B01AC",
    "C01AA", "C01CA", "C09AA", "C09CA",
    "N02AA", "N05CD", "N01AH",
    "L04AD", "L01EG",
    "R03AC", "R03DC",
    "H02AA", "H01AA",
    "B05BB", "B05XA",
    "A02BA", "A02BC",
    "D01AC")

# Initialize an empty list to store results
result <- list()

prescriptions_transformed_survival  <- prescriptions_transformed_survival  %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", predictor, prescriptions_transformed_survival)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}

# Combine all results into a single data frame
final_result <- do.call(rbind, result)

# Print the final results
print_table(final_result)

rm(final_result, predictors, test_result, param, predictor, km_plots)

```

### 6.4.3. Outcome 3: Length of ICU Stay by Prescriptions Data

```{r Length of ICU Stay by Prescriptions Data Exploratory analysis}
prescriptions_LOS_numbers <- prescriptions_los_outcome %>%
  group_by(SUBJECT_ID_COMPOSE, ICUSTAY_ID, LOS) %>%
  summarise(
    PRESCRIPTIONS_NUM = n_distinct(DRUG_NAME_GENERIC),  # Count unique prescriptions per patient
    .groups = "drop"
  ) %>%
  mutate(
    PRESCRIPTIONS_NUM = cut(PRESCRIPTIONS_NUM,
                            breaks = c(0, 1, 3, 10, 20, 30, Inf),  # Include 0-1 as the first interval
                            labels = c("1", "1-3", "3-10", "10-20", "20-30", ">30"),  # Five intervals
                            right = FALSE)  # Include the left boundary in each group
  )

# Analyze LOS by prescription intervals
result_prescriptions_num <- analyze_predictor_LOS(
  prescriptions_LOS_numbers,
  predictor = "PRESCRIPTIONS_NUM",
  LOS = "LOS",
  patient_id = "SUBJECT_ID_COMPOSE"
)

# Print the result
print_table(result_prescriptions_num)

# Remove intermediate objects
rm(result_prescriptions_num, prescriptions_LOS_numbers, prescriptions_los_outcome)

```

PRESCRIPTIONS_NUM is a significant predictor for the length of ICU stay based on mixed-effects model results. All groups demonstrate statistical significance (p < 0.001), indicating that the number of prescriptions is associated with variations in ICU stay duration.

PRESCRIPTIONS_NUM should be included in future models for ICU stay prediction.

```{r Length of LOS by Prescriotion Exploratory analysis}

# Define predictors to evaluate
predictors <- c("J01CA", "J01DD", "J01DH", "J01GB", "J02AC",
    "B01AA", "B01AB", "B01AC",
    "C01AA", "C01CA", "C09AA", "C09CA",
    "N02AA", "N05CD", "N01AH",
    "L04AD", "L01EG",
    "R03AC", "R03DC",
    "H02AA", "H01AA",
    "B05BB", "B05XA",
    "A02BA", "A02BC",
    "D01AC")

# Initialize an empty list to store results
results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform assessment for the current predictor
  result <- analyze_predictor_LOS(data = prescriptions_transformed_los, predictor = predictor, LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
  
  # Append the result to the list
  results[[predictor]] <- result
}

# Combine all results into a single data frame
table <- do.call(rbind, lapply(names(results), function(predictor) {
  cbind(Predictor = predictor, results[[predictor]])
}))

# Convert to data frame for better formatting
table <- as.data.frame(table)

# Print the final HR table
print_table(table)

rm(table, results, predictors, predictor)

```

# 7. Laborotory Analyses Data (Blood)
## 7.1. Read data

``` {r read data blood analyses}
labs_blood <- read.csv("../data/raw/cleaned/LABEVENTS_clean.csv", stringsAsFactors = TRUE) %>%
  filter(FLUID == "BLOOD") %>%
  mutate(across(where(is.character), as.factor))  %>%
  filter(SUBJECT_ID %in% subject_ids_adults) %>%
    filter(HADM_ID != 0 ) %>%
  select(-ITEMID)

labs_blood_gas <- labs_blood %>%
  filter(CATEGORY == "BLOOD GAS") %>%
  select(SUBJECT_ID_COMPOSE, LABEL, Last_VALUENUM, Mean_VALUENUM) %>%
  distinct()

hematology <- labs_blood %>%
  filter(CATEGORY == "HEMATOLOGY") %>%
  select(SUBJECT_ID_COMPOSE, LABEL,  Last_VALUENUM, Mean_VALUENUM) %>%
  distinct()

chemistry <- labs_blood %>%
  filter(CATEGORY == "CHEMISTRY") %>%
  select(SUBJECT_ID_COMPOSE, LABEL,  Last_VALUENUM, Mean_VALUENUM) %>%
  distinct()
  
skimr::skim(labs_blood %>%
  select(-SUBJECT_ID, -HADM_ID, -SUBJECT_ID_COMPOSE))
```

```{r find intersections}

# Find intersections between each pair of datasets
intersection_gas_hematology <- intersect(labs_blood_gas$LABEL, hematology$LABEL)
intersection_gas_chemistry <- intersect(labs_blood_gas$LABEL, chemistry$LABEL)
intersection_hematology_chemistry <- intersect(hematology$LABEL, chemistry$LABEL)

# Print the intersection table
print_table(intersection_gas_hematology)
print_table(intersection_gas_chemistry)
print_table(intersection_hematology_chemistry)

```

It was decided to analyse the same blood variables as Glucose, hemoglobin or d-dimer separately, because the methods to measure variables are different.

## 7.2.   Descriptive Statistics (Laboratory Data (Blood))
### 7.2.1. Descriptive statistics for categorical variables (Laboratory Data (Blood))

```{r Descriptive statistics for procedures for categorical vars (Laboratory Data (Blood)}
# Clean and summarize the categorical data for all factor variables
labs_blood %>%
  select(CATEGORY) %>%
  select(where(is.factor)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  group_by(Variable, Value) %>%
  summarise(n = n(), .groups = 'drop') %>%
  group_by(Variable) %>%
  mutate(`No data` = sum(is.na(Value)),
         `% by group` = (n / sum(n)) * 100) %>%
  ungroup() %>%
  select(Variable, Value, n, `% by group`, `No data`) %>%
  arrange(Variable, desc(n)) %>%
  flextable() %>%
  merge_v("Variable") %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

### 7.2.2. Descriptive statistics for Numerical Variables (Laboratory Data (Blood Gas))
#### 7.2.2.1. Descriptive statistics for Numerical Variables (Laboratory Data (Blood Gas))

Perform data transformation (Blood Gas the Last Value).

``` {r (Blood Gas last) Data transformation}

# Combine the hemoglobine data with labs_blood_gas
labs_blood_gas_combined_last <- labs_blood_gas %>%
  select(-Mean_VALUENUM) %>%
  pivot_wider(
    names_from = LABEL,
    values_from = Last_VALUENUM,
    values_fill = list(VALUENUM = NA)
  ) %>%
  select(-INTUBATED, -`SPECIMEN TYPE`) %>%
  distinct()

labs_blood_gas_combined_last <- labs_blood_gas_combined_last %>%
  group_by(SUBJECT_ID_COMPOSE) %>%
  summarise(across(
    everything(), 
    ~ if (all(is.na(.))) NA else na.omit(.)[1], # Keep the first non-NA value for each column
    .names = "{.col}"
  )) %>%
  ungroup()
  
# Rename columns to replace spaces and commas
labs_blood_gas_combined_last <- labs_blood_gas_combined_last %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  rename_with(~gsub(",_", "_", .)) %>%
  rename(
    ALVEOLAR_ARTERIAL_GRADIENT = "ALVEOLAR-ARTERIAL_GRADIENT"
  )

```

```{r Descriptive statistics for procedures for categorical vars (Laboratory Data (Blood gas Last)}

# Summarize the statistics for each numeric variable
labs_blood_gas_combined_last %>%
  select(where(is.numeric)) %>% 
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))

```

Perform data transformation (Blood Gas the Mean Value).

``` {r (Blood Gas mean) Data transformation}

# Combine the hemoglobine data with labs_blood_gas
labs_blood_gas_combined_mean <- labs_blood_gas %>%
  select(-Last_VALUENUM) %>%
  pivot_wider(
    names_from = LABEL,
    values_from = Mean_VALUENUM,
    values_fill = list(VALUENUM = NA)
  ) %>%
  select(-INTUBATED, -`SPECIMEN TYPE`) %>%
  distinct()

labs_blood_gas_combined_mean <- labs_blood_gas_combined_mean %>%
  group_by(SUBJECT_ID_COMPOSE) %>%
  summarise(across(
    everything(), 
    ~ if (all(is.na(.))) NA else na.omit(.)[1], # Keep the first non-NA value for each column
    .names = "{.col}"
  )) %>%
  ungroup()
  
# Rename columns to replace spaces and commas
labs_blood_gas_combined_mean <- labs_blood_gas_combined_mean %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  rename_with(~gsub(",_", "_", .)) %>%
  rename(
    ALVEOLAR_ARTERIAL_GRADIENT = "ALVEOLAR-ARTERIAL_GRADIENT"
  )

```

```{r Descriptive statistics for procedures for categorical vars (Laboratory Data (Blood gas Mean)}

# Summarize the statistics for each numeric variable
labs_blood_gas_combined_mean %>%
  select(where(is.numeric)) %>% 
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))

```

#### 7.2.2.2. Check for Outliers

Check Outliers for Blood Gas Last Values.

```{r Outliers check blood gas last}
# Function to identify outliers based on IQR
find_outliers <- function(data, column) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  data %>%
    filter(data[[column]] < lower_bound | data[[column]] > upper_bound)
}

# Get numeric column names
numeric_columns <- labs_blood_gas_combined_last %>%
  select(where(is.numeric)) %>%
  names()

# Calculate outlier statistics for each column
outlier_summary <- lapply(numeric_columns, function(col) {
  # Find outliers
  outlier_data <- find_outliers(labs_blood_gas_combined_last, col)
  
  # Summary stats
  total_outliers <- nrow(outlier_data)
  total_values <- nrow(labs_blood_gas_combined_last)
  percentage_outliers <- (total_outliers / total_values) * 100
  
  # Return a summary row
  data.frame(
    Variable = col,
    Total_Values = total_values,
    Total_Outliers = total_outliers,
    Percentage_Outliers = round(percentage_outliers, 2)
  )
})

# Combine the results into a single table
outlier_summary_table <- do.call(rbind, outlier_summary)

# Print the table
print_table(outlier_summary_table)

```
All outliers levels are less than 5 % (except Lactate, Ventilation Rate, Oxygen saturation).
The outliers presence could be natural for this type of data.

```{r Outliers check blood gas mean}
# Function to identify outliers based on IQR
find_outliers <- function(data, column) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  data %>%
    filter(data[[column]] < lower_bound | data[[column]] > upper_bound)
}

# Get numeric column names
numeric_columns <- labs_blood_gas_combined_mean %>%
  select(where(is.numeric)) %>%
  names()

# Calculate outlier statistics for each column
outlier_summary <- lapply(numeric_columns, function(col) {
  # Find outliers
  outlier_data <- find_outliers(labs_blood_gas_combined_mean, col)
  
  # Summary stats
  total_outliers <- nrow(outlier_data)
  total_values <- nrow(labs_blood_gas_combined_mean)
  percentage_outliers <- (total_outliers / total_values) * 100
  
  # Return a summary row
  data.frame(
    Variable = col,
    Total_Values = total_values,
    Total_Outliers = total_outliers,
    Percentage_Outliers = round(percentage_outliers, 2)
  )
})

# Combine the results into a single table
outlier_summary_table <- do.call(rbind, outlier_summary)

# Print the table
print_table(outlier_summary_table)

```

All outliers levels are less than 5 % (except Lactate, pCO2).
The outliers presence could be natural for this type of data.

### 7.2.3. Descriptive statistics (Laboratory Data (Hematology))
#### 7.2.3.1. Descriptive statistics for Numerical Variables (Laboratory Data (Hematology))

Perform data transformation (Hematology Last Values).

``` {r Hematology Data Last transformation}
unique_labels_list <- hematology %>%
  group_by(LABEL) %>%
  summarise(Count = sum(!is.na(Last_VALUENUM)), .groups = "drop") %>%
  filter(Count > 1000) %>%
  arrange(desc(Count)) %>%
  mutate(LABEL = as.character(LABEL)) %>%  # Convert LABEL to character
  filter(LABEL %in% c("HEMATOCRIT", "PLATELET COUNT", "WHITE BLOOD CELLS", "HEMOGLOBIN", 
                      "MCHC", "RED BLOOD CELLS", "MCH", "MCV", "RDW", "PTT", "INR(PT)", 
                      "PT", "LYMPHOCYTES",  "NEUTROPHILS",  "MONOCYTES", "EOSINOPHILS", 
                      "BASOPHILS", "FIBRINOGEN, FUNCTIONAL", "RETICULOCYTE COUNT, AUTOMATED", 
                      "SEDIMENTATION RATE", "D-DIMER")) %>%
  pull(LABEL) %>%
  as.list()

hematology_last <- hematology %>%
  select(-Mean_VALUENUM) %>%
  # Ensure LABEL is in the unique_labels_list
  filter(LABEL %in% unique_labels_list) %>%
  # Pivot wider using the combined column
  pivot_wider(
    names_from = LABEL,
    values_from = Last_VALUENUM,
    values_fill = list(Last_VALUENUM = NA)
  ) %>%
  distinct()

hematology_combined_last <- hematology_last %>%
  group_by(SUBJECT_ID_COMPOSE) %>%
  summarise(across(
    everything(), 
    ~ if (all(is.na(.))) NA else na.omit(.)[1], # Keep the first non-NA value for each column
    .names = "{.col}"
  )) %>%
  ungroup()

# Rename columns to replace spaces and commas
hematology_combined_last <- hematology_combined_last %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  rename_with(~gsub(",_", "_", .)) %>%
  rename(
    INR_PT = `INR(PT)`, 
    D_DIMER = `D-DIMER`
  )

```

```{r Descriptive statistics for procedures for categorical vars (Laboratory Data (Hematology last)}

# Summarize the statistics for each numeric variable
hematology_combined_last %>%
  select(where(is.numeric)) %>% 
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))

```

Perform data transformation (Hematology Mean Values).

``` {r Hematology Data Mean transformation}
unique_labels_list <- hematology %>%
  group_by(LABEL) %>%
  summarise(Count = sum(!is.na(Mean_VALUENUM)), .groups = "drop") %>%
  filter(Count > 1000) %>%
  arrange(desc(Count)) %>%
  mutate(LABEL = as.character(LABEL)) %>%  # Convert LABEL to character
  filter(LABEL %in% c("HEMATOCRIT", "PLATELET COUNT", "WHITE BLOOD CELLS", "HEMOGLOBIN", 
                      "MCHC", "RED BLOOD CELLS", "MCH", "MCV", "RDW", "PTT", "INR(PT)", 
                      "PT", "LYMPHOCYTES",  "NEUTROPHILS",  "MONOCYTES", "EOSINOPHILS", 
                      "BASOPHILS", "FIBRINOGEN, FUNCTIONAL", "RETICULOCYTE COUNT, AUTOMATED", 
                      "SEDIMENTATION RATE", "D-DIMER")) %>%
  pull(LABEL) %>%
  as.list()

hematology_mean <- hematology %>%
  select(-Last_VALUENUM) %>%
  # Ensure LABEL is in the unique_labels_list
  filter(LABEL %in% unique_labels_list) %>%
  # Pivot wider using the combined column
  pivot_wider(
    names_from = LABEL,
    values_from = Mean_VALUENUM,
    values_fill = list(Mean_VALUENUM = NA)
  ) %>%
  distinct()

hematology_combined_mean <- hematology_mean %>%
  group_by(SUBJECT_ID_COMPOSE) %>%
  summarise(across(
    everything(), 
    ~ if (all(is.na(.))) NA else na.omit(.)[1], # Keep the first non-NA value for each column
    .names = "{.col}"
  )) %>%
  ungroup()

# Rename columns to replace spaces and commas
hematology_combined_mean <- hematology_combined_mean %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  rename_with(~gsub(",_", "_", .)) %>%
  rename(
    INR_PT = `INR(PT)`, 
    D_DIMER = `D-DIMER`
  )

```

```{r Descriptive statistics for procedures for categorical vars (Laboratory Data (Hematology mean)}

# Summarize the statistics for each numeric variable
hematology_combined_mean %>%
  select(where(is.numeric)) %>% 
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))

```

#### 7.2.3.2. Check for Outliers

```{r Outliers check hematology last}
# Function to identify outliers based on IQR
find_outliers <- function(data, column) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  data %>%
    filter(data[[column]] < lower_bound | data[[column]] > upper_bound)
}

# Get numeric column names
numeric_columns <- hematology_combined_last %>%
  select(where(is.numeric)) %>%
  names()

# Calculate outlier statistics for each column
outlier_summary <- lapply(numeric_columns, function(col) {
  # Find outliers
  outlier_data <- find_outliers(hematology_combined_last, col)
  
  # Summary stats
  total_outliers <- nrow(outlier_data)
  total_values <- nrow(hematology_combined_last)
  percentage_outliers <- (total_outliers / total_values) * 100
  
  # Return a summary row
  data.frame(
    Variable = col,
    Total_Values = total_values,
    Total_Outliers = total_outliers,
    Percentage_Outliers = round(percentage_outliers, 2)
  )
})

# Combine the results into a single table
outlier_summary_table <- do.call(rbind, outlier_summary)

# Print the table
print_table(outlier_summary_table)

```

```{r Outliers check hematology mean}
# Function to identify outliers based on IQR
find_outliers <- function(data, column) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  data %>%
    filter(data[[column]] < lower_bound | data[[column]] > upper_bound)
}

# Get numeric column names
numeric_columns <- hematology_combined_mean %>%
  select(where(is.numeric)) %>%
  names()

# Calculate outlier statistics for each column
outlier_summary <- lapply(numeric_columns, function(col) {
  # Find outliers
  outlier_data <- find_outliers(hematology_combined_mean, col)
  
  # Summary stats
  total_outliers <- nrow(outlier_data)
  total_values <- nrow(hematology_combined_mean)
  percentage_outliers <- (total_outliers / total_values) * 100
  
  # Return a summary row
  data.frame(
    Variable = col,
    Total_Values = total_values,
    Total_Outliers = total_outliers,
    Percentage_Outliers = round(percentage_outliers, 2)
  )
})

# Combine the results into a single table
outlier_summary_table <- do.call(rbind, outlier_summary)

# Print the table
print_table(outlier_summary_table)

```

### 7.2.4. Descriptive statistics (Laboratory Data (Chemistry))
#### 7.2.4.1. Descriptive statistics for Numerical Variables (Laboratory Data (Chemistry))

Perform data transformation (Chemistry Last Values).

``` {r Chemistry Data transformation last}

unique_labels_list <- chemistry %>%
  group_by(LABEL) %>%
  summarise(Count = sum(!is.na(Last_VALUENUM)), .groups = "drop") %>%
  filter(Count > 1000) %>%
  arrange(desc(Count)) %>%
  mutate(LABEL = as.character(LABEL)) %>%  # Convert LABEL to character
  filter(LABEL %in% c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "D-DIMER",
                      "ANION GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM, TOTAL", 
                      "BILIRUBIN, TOTAL", 
                      "ALANINE AMINOTRANSFERASE (ALT)", 
                      "ASPARATE AMINOTRANSFERASE (AST)", 
                      "C-REACTIVE PROTEIN", 
                      "TROPONIN T", 
                      "LACTATE DEHYDROGENASE (LD)")) %>%
  pull(LABEL) %>%
  as.list()

chemistry_last <- chemistry %>%
  select(-Mean_VALUENUM) %>%
  # Ensure LABEL is in the unique_labels_list
  filter(LABEL %in% unique_labels_list) %>%
  # Pivot wider using the combined column
  pivot_wider(
    names_from = LABEL,
    values_from = Last_VALUENUM,
    values_fill = list(Last_VALUENUM = NA)
  ) %>%
  distinct()

chemistry_combined_last <- chemistry_last %>%
  group_by(SUBJECT_ID_COMPOSE) %>%
  summarise(across(
    everything(), 
    ~ if (all(is.na(.))) NA else na.omit(.)[1], # Keep the first non-NA value for each column
    .names = "{.col}"
  )) %>%
  ungroup()

# Rename columns to replace spaces and commas
chemistry_combined_last <- chemistry_combined_last %>%
  rename(
    ALT = `ALANINE AMINOTRANSFERASE (ALT)`,
    AST = `ASPARATE AMINOTRANSFERASE (AST)`,
    CRP = `C-REACTIVE PROTEIN`,
    LD = `LACTATE DEHYDROGENASE (LD)`
  ) %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  rename_with(~gsub(",_", "_", .))
  
```

```{r Descriptive statistics for numerical vars (Laboratory Data (Chemistry last)}

# Summarize the statistics for each numeric variable
chemistry_combined_last %>%
  select(where(is.numeric)) %>% 
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

Perform data transformation (Chemistry Mean values by patient).

``` {r Chemistry Data transformation mean}

unique_labels_list <- chemistry %>%
  group_by(LABEL) %>%
  summarise(Count = sum(!is.na(Mean_VALUENUM)), .groups = "drop") %>%
  filter(Count > 1000) %>%
  arrange(desc(Count)) %>%
  mutate(LABEL = as.character(LABEL)) %>%  # Convert LABEL to character
  filter(LABEL %in% c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "D-DIMER",
                      "ANION GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM, TOTAL", 
                      "BILIRUBIN, TOTAL", 
                      "ALANINE AMINOTRANSFERASE (ALT)", 
                      "ASPARATE AMINOTRANSFERASE (AST)", 
                      "C-REACTIVE PROTEIN", 
                      "TROPONIN T", 
                      "LACTATE DEHYDROGENASE (LD)")) %>%
  pull(LABEL) %>%
  as.list()

chemistry_mean <- chemistry %>%
  select(-Last_VALUENUM) %>%
  # Ensure LABEL is in the unique_labels_list
  filter(LABEL %in% unique_labels_list) %>%
  # Pivot wider using the combined column
  pivot_wider(
    names_from = LABEL,
    values_from = Mean_VALUENUM,
    values_fill = list(Mean_VALUENUM = NA)
  ) %>%
  distinct()

chemistry_combined_mean <- chemistry_mean %>%
  group_by(SUBJECT_ID_COMPOSE) %>%
  summarise(across(
    everything(), 
    ~ if (all(is.na(.))) NA else na.omit(.)[1], # Keep the first non-NA value for each column
    .names = "{.col}"
  )) %>%
  ungroup()

# Rename columns to replace spaces and commas
chemistry_combined_mean <- chemistry_combined_mean %>%
  rename(
    ALT = `ALANINE AMINOTRANSFERASE (ALT)`,
    AST = `ASPARATE AMINOTRANSFERASE (AST)`,
    CRP = `C-REACTIVE PROTEIN`,
    LD = `LACTATE DEHYDROGENASE (LD)`
  ) %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  rename_with(~gsub(",_", "_", .))
  
```

```{r Descriptive statistics for numerical vars (Laboratory Data (Chemistry mean)}

# Summarize the statistics for each numeric variable
chemistry_combined_mean %>%
  select(where(is.numeric)) %>% 
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

#### 7.2.4.2.   Check for Outliers

```{r Outliers check chemistry last}
# Function to identify outliers based on IQR
find_outliers <- function(data, column) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  data %>%
    filter(data[[column]] < lower_bound | data[[column]] > upper_bound)
}

# Get numeric column names
numeric_columns <- chemistry_combined_last %>%
  select(where(is.numeric)) %>%
  names()

# Calculate outlier statistics for each column
outlier_summary <- lapply(numeric_columns, function(col) {
  # Find outliers
  outlier_data <- find_outliers(chemistry_combined_last, col)
  
  # Summary stats
  total_outliers <- nrow(outlier_data)
  total_values <- nrow(chemistry_combined_last)
  percentage_outliers <- (total_outliers / total_values) * 100
  
  # Return a summary row
  data.frame(
    Variable = col,
    Total_Values = total_values,
    Total_Outliers = total_outliers,
    Percentage_Outliers = round(percentage_outliers, 2)
  )
})

# Combine the results into a single table
outlier_summary_table <- do.call(rbind, outlier_summary)

# Print the table
print_table(outlier_summary_table)

```

```{r Outliers check chemistry mean}
# Function to identify outliers based on IQR
find_outliers <- function(data, column) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  data %>%
    filter(data[[column]] < lower_bound | data[[column]] > upper_bound)
}

# Get numeric column names
numeric_columns <- chemistry_combined_mean %>%
  select(where(is.numeric)) %>%
  names()

# Calculate outlier statistics for each column
outlier_summary <- lapply(numeric_columns, function(col) {
  # Find outliers
  outlier_data <- find_outliers(chemistry_combined_mean, col)
  
  # Summary stats
  total_outliers <- nrow(outlier_data)
  total_values <- nrow(chemistry_combined_mean)
  percentage_outliers <- (total_outliers / total_values) * 100
  
  # Return a summary row
  data.frame(
    Variable = col,
    Total_Values = total_values,
    Total_Outliers = total_outliers,
    Percentage_Outliers = round(percentage_outliers, 2)
  )
})

# Combine the results into a single table
outlier_summary_table <- do.call(rbind, outlier_summary)

# Print the table
print_table(outlier_summary_table)

```

## 7.3. Visualisation Analysis by Outcome
### 7.3.1. Outcome 1: Death Status by Laboratory Data (Blood)
#### 7.3.1.1. Blood Gas
##### 7.3.1.1.1. Blood Gas the Last Values

``` {r Death Status by Laboratory Data (Blood Gas last)}
labs_blood_gas_death_outcome_last <- labs_blood_gas_combined_last %>%
  left_join(Death_status_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL_FLAG))

# Visualise how differ all numeric vars according to death status
# Filter numeric variables with sufficient variance
numeric_vars <- labs_blood_gas_death_outcome_last %>%
  select(-SUBJECT_ID_COMPOSE, -SURVIVAL_FLAG) %>%
  select(where(is.numeric)) %>%
  summarise(across(everything(), ~ var(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Variance") %>%
  filter(Variance > 0) %>%
  pull(Variable)

# Filter data for plotting
filtered_data <- labs_blood_gas_death_outcome_last %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, all_of(numeric_vars)) %>%
  group_by(SURVIVAL_FLAG) %>%
  summarise(across(everything(), ~ mean(., na.rm = TRUE), .names = "{.col}"), .groups = "drop")

# Melt the data for easier plotting
melted_data <- filtered_data %>%
  pivot_longer(cols = -c(SURVIVAL_FLAG), names_to = "Variable", values_to = "Value") %>%
  filter(Variable != "SUBJECT_ID_COMPOSE")

# Plot boxplots for all variables grouped by survival flag
ggplot(melted_data, aes(x = SURVIVAL_FLAG, y = Value, fill = SURVIVAL_FLAG)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  theme_custom +
  labs(
    title = "Boxplots of Mean Variables for Last Values by Survival Status",
    x = "Survival Flag",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text = element_text(size = 6))

ggplot(melted_data, aes(x = Variable, y = Value, fill = as.factor(SURVIVAL_FLAG))) +
  # Jittered points with black outline
  geom_jitter(
    position = position_jitter(width = 0.2), 
    alpha = 1, 
    shape = 21,      # Shape with both fill and border
    color = "black", # Black border
    stroke = 0.5     # Border thickness
  ) +
  # Custom theme and colors
  theme_custom +
  scale_fill_manual(values = c("0" = color_palette[25], "1" = color_palette[20])) +
  
  # Labels
  labs(
    title = "Scatter Plot of Mean Variables for Last Values by Survival Status",
    x = "Variables",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  
  # Adjust aesthetics
  theme(
    axis.text.x = element_text(angle =90, hjust = 1, size = 6),
    legend.position = "none"
  )


rm(melted_data, filtered_data, numeric_vars, plot)
```

##### 7.3.1.1.2. Blood Gas the Mean Values by Patient

``` {r Death Status by Laboratory Data (Blood Gas Mean)}
labs_blood_gas_death_outcome_mean <- labs_blood_gas_combined_mean %>%
  left_join(Death_status_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL_FLAG))

# Visualise how differ all numeric vars according to death status
# Filter numeric variables with sufficient variance
numeric_vars <- labs_blood_gas_death_outcome_mean %>%
  select(-SUBJECT_ID_COMPOSE, -SURVIVAL_FLAG) %>%
  select(where(is.numeric)) %>%
  summarise(across(everything(), ~ var(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Variance") %>%
  filter(Variance > 0) %>%
  pull(Variable)

# Filter data for plotting
filtered_data <- labs_blood_gas_death_outcome_mean %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, all_of(numeric_vars)) %>%
  group_by(SURVIVAL_FLAG) %>%
  summarise(across(everything(), ~ mean(., na.rm = TRUE), .names = "{.col}"), .groups = "drop")

# Melt the data for easier plotting
melted_data <- filtered_data %>%
  pivot_longer(cols = -c(SURVIVAL_FLAG), names_to = "Variable", values_to = "Value") %>%
  filter(Variable != "SUBJECT_ID_COMPOSE")

# Plot boxplots for all variables grouped by survival flag
ggplot(melted_data, aes(x = SURVIVAL_FLAG, y = Value, fill = SURVIVAL_FLAG)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  theme_custom +
  labs(
    title = "Boxplots of Mean Variables for Mean Values (by patient)  by Survival Status",
    x = "Survival Flag",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text = element_text(size = 6))

ggplot(melted_data, aes(x = Variable, y = Value, fill = as.factor(SURVIVAL_FLAG))) +
  # Jittered points with black outline
  geom_jitter(
    position = position_jitter(width = 0.2), 
    alpha = 1, 
    shape = 21,      # Shape with both fill and border
    color = "black", # Black border
    stroke = 0.5     # Border thickness
  ) +
  # Custom theme and colors
  theme_custom +
  scale_fill_manual(values = c("0" = color_palette[25], "1" = color_palette[20])) +
  
  # Labels
  labs(
    title = "Scatter Plot of Mean Variables for Mean Values (by patient) by Survival Status",
    x = "Variables",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  
  # Adjust aesthetics
  theme(
    axis.text.x = element_text(angle =90, hjust = 1, size = 6),
    legend.position = "none"
  )

rm(melted_data, filtered_data, numeric_vars, plot)
```

#### 7.3.1.2. Hematology
##### 7.3.1.2.1.    Hematology the Last Values

```{r Death Status by Laboratory Data (Hematology last)}
hematology_death_outcome_last <- hematology_combined_last %>%
  left_join(Death_status_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL_FLAG))

# Visualise how differ all numeric vars according to death status
# Filter numeric variables with sufficient variance
numeric_vars <- hematology_death_outcome_last %>%
  select(-SUBJECT_ID_COMPOSE, -SURVIVAL_FLAG) %>%
  select(where(is.numeric)) %>%
  summarise(across(everything(), ~ var(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Variance") %>%
  filter(Variance > 0) %>%
  pull(Variable)

# Filter data for plotting
filtered_data <- hematology_death_outcome_last %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, all_of(numeric_vars)) %>%
  group_by(SURVIVAL_FLAG) %>%
  summarise(across(everything(), ~ mean(., na.rm = TRUE), .names = "{.col}"), .groups = "drop")

# Melt the data for easier plotting
melted_data <- filtered_data %>%
  pivot_longer(cols = -c(SURVIVAL_FLAG), names_to = "Variable", values_to = "Value") %>%
  filter(Variable != "SUBJECT_ID_COMPOSE")

# Plot boxplots for all variables grouped by survival flag
ggplot(melted_data, aes(x = SURVIVAL_FLAG, y = Value, fill = SURVIVAL_FLAG)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  theme_custom +
  labs(
    title = "Boxplots of Mean Variables for Last Values by Survival Status",
    x = "Survival Flag",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text = element_text(size = 6))

ggplot(melted_data, aes(x = Variable, y = Value, fill = as.factor(SURVIVAL_FLAG))) +
  # Jittered points with black outline
  geom_jitter(
    position = position_jitter(width = 0.2), 
    alpha = 1, 
    shape = 21,      # Shape with both fill and border
    color = "black", # Black border
    stroke = 0.5     # Border thickness
  ) +
  # Custom theme and colors
  theme_custom +
  scale_fill_manual(values = c("0" = color_palette[25], "1" = color_palette[20])) +
  
  # Labels
  labs(
    title = "Scatter Plot of Mean Variables for Last Values by Survival Status",
    x = "Variables",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  
  # Adjust aesthetics
  theme(
    axis.text.x = element_text(angle =90, hjust = 1, size = 6)
  )


rm(melted_data, filtered_data, numeric_vars, plot)
```

##### 7.3.1.2.2.    Hematology the Mean Values by Patients

```{r Death Status by Laboratory Data (Hematology mean)}
hematology_death_outcome_mean <- hematology_combined_mean %>%
  left_join(Death_status_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL_FLAG))

# Visualise how differ all numeric vars according to death status
# Filter numeric variables with sufficient variance
numeric_vars <- hematology_death_outcome_mean %>%
  select(-SUBJECT_ID_COMPOSE, -SURVIVAL_FLAG) %>%
  select(where(is.numeric)) %>%
  summarise(across(everything(), ~ var(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Variance") %>%
  filter(Variance > 0) %>%
  pull(Variable)

# Filter data for plotting
filtered_data <- hematology_death_outcome_mean %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, all_of(numeric_vars)) %>%
  group_by(SURVIVAL_FLAG) %>%
  summarise(across(everything(), ~ mean(., na.rm = TRUE), .names = "{.col}"), .groups = "drop")

# Melt the data for easier plotting
melted_data <- filtered_data %>%
  pivot_longer(cols = -c(SURVIVAL_FLAG), names_to = "Variable", values_to = "Value") %>%
  filter(Variable != "SUBJECT_ID_COMPOSE")

# Plot boxplots for all variables grouped by survival flag
ggplot(melted_data, aes(x = SURVIVAL_FLAG, y = Value, fill = SURVIVAL_FLAG)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  theme_custom +
  labs(
    title = "Boxplots of Mean Variables for Last Values by Survival Status",
    x = "Survival Flag",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text = element_text(size = 6))

ggplot(melted_data, aes(x = Variable, y = Value, fill = as.factor(SURVIVAL_FLAG))) +
  # Jittered points with black outline
  geom_jitter(
    position = position_jitter(width = 0.2), 
    alpha = 1, 
    shape = 21,      # Shape with both fill and border
    color = "black", # Black border
    stroke = 0.5     # Border thickness
  ) +
  # Custom theme and colors
  theme_custom +
  scale_fill_manual(values = c("0" = color_palette[25], "1" = color_palette[20])) +
  
  # Labels
  labs(
    title = "Scatter Plot of Mean Variables for Last Values by Survival Status",
    x = "Variables",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  
  # Adjust aesthetics
  theme(
    axis.text.x = element_text(angle =90, hjust = 1, size = 6)
  )


rm(melted_data, filtered_data, numeric_vars, plot)
```

#### 7.3.1.3. Blood Chemistry
##### 7.3.1.3.1. Blood Chemistry the Last Values

```{r Death Status by Laboratory Data (Chemistry last)}
chemistry_death_outcome_last <- chemistry_combined_last %>%
  left_join(Death_status_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL_FLAG))

# Visualise how differ all numeric vars according to death status
# Filter numeric variables with sufficient variance
numeric_vars <- chemistry_death_outcome_last %>%
  select(-SUBJECT_ID_COMPOSE, -SURVIVAL_FLAG) %>%
  select(where(is.numeric)) %>%
  summarise(across(everything(), ~ var(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Variance") %>%
  filter(Variance > 0) %>%
  pull(Variable)

# Filter data for plotting
filtered_data <- chemistry_death_outcome_last %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, all_of(numeric_vars)) %>%
  group_by(SURVIVAL_FLAG) %>%
  summarise(across(everything(), ~ mean(., na.rm = TRUE), .names = "{.col}"), .groups = "drop")

# Melt the data for easier plotting
melted_data <- filtered_data %>%
  pivot_longer(cols = -c(SURVIVAL_FLAG), names_to = "Variable", values_to = "Value") %>%
  filter(Variable != "SUBJECT_ID_COMPOSE")

# Plot boxplots for all variables grouped by survival flag
ggplot(melted_data, aes(x = SURVIVAL_FLAG, y = Value, fill = SURVIVAL_FLAG)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  theme_custom +
  labs(
    title = "Boxplots of Mean Variables for Last Values by Survival Status",
    x = "Survival Flag",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text = element_text(size = 6))

ggplot(melted_data, aes(x = Variable, y = Value, fill = as.factor(SURVIVAL_FLAG))) +
  # Jittered points with black outline
  geom_jitter(
    position = position_jitter(width = 0.2), 
    alpha = 1, 
    shape = 21,      # Shape with both fill and border
    color = "black", # Black border
    stroke = 0.5     # Border thickness
  ) +
  # Custom theme and colors
  theme_custom +
  scale_fill_manual(values = c("0" = color_palette[25], "1" = color_palette[20])) +
  
  # Labels
  labs(
    title = "Scatter Plot of Mean Variables for Last Values by Survival Status",
    x = "Variables",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  
  # Adjust aesthetics
  theme(
    axis.text.x = element_text(angle =90, hjust = 1, size = 6)
  )


rm(melted_data, filtered_data, numeric_vars, plot)
```

##### 7.3.1.3.1. Blood Chemistry the Mean Values by Patient

```{r Death Status by Laboratory Data (Chemistry mean)}
chemistry_death_outcome_mean <- chemistry_combined_mean %>%
  left_join(Death_status_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL_FLAG))

# Visualise how differ all numeric vars according to death status
# Filter numeric variables with sufficient variance
numeric_vars <- chemistry_death_outcome_mean %>%
  select(-SUBJECT_ID_COMPOSE, -SURVIVAL_FLAG) %>%
  select(where(is.numeric)) %>%
  summarise(across(everything(), ~ var(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Variance") %>%
  filter(Variance > 0) %>%
  pull(Variable)

# Filter data for plotting
filtered_data <- chemistry_death_outcome_mean %>%
  select(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG, all_of(numeric_vars)) %>%
  group_by(SURVIVAL_FLAG) %>%
  summarise(across(everything(), ~ mean(., na.rm = TRUE), .names = "{.col}"), .groups = "drop")

# Melt the data for easier plotting
melted_data <- filtered_data %>%
  pivot_longer(cols = -c(SURVIVAL_FLAG), names_to = "Variable", values_to = "Value") %>%
  filter(Variable != "SUBJECT_ID_COMPOSE")

# Plot boxplots for all variables grouped by survival flag
ggplot(melted_data, aes(x = SURVIVAL_FLAG, y = Value, fill = SURVIVAL_FLAG)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  theme_custom +
  labs(
    title = "Boxplots of Mean Variables for Last Values by Survival Status",
    x = "Survival Flag",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text = element_text(size = 6))

ggplot(melted_data, aes(x = Variable, y = Value, fill = as.factor(SURVIVAL_FLAG))) +
  # Jittered points with black outline
  geom_jitter(
    position = position_jitter(width = 0.2), 
    alpha = 1, 
    shape = 21,      # Shape with both fill and border
    color = "black", # Black border
    stroke = 0.5     # Border thickness
  ) +
  # Custom theme and colors
  theme_custom +
  scale_fill_manual(values = c("0" = color_palette[25], "1" = color_palette[20])) +
  
  # Labels
  labs(
    title = "Scatter Plot of Mean Variables for Last Values by Survival Status",
    x = "Variables",
    y = "Mean Value",
    fill = "Survival Flag"
  ) +
  
  # Adjust aesthetics
  theme(
    axis.text.x = element_text(angle =90, hjust = 1, size = 6)
  )


rm(melted_data, filtered_data, numeric_vars, plot)
```

### 7.3.2. Outcome 2: Length of Survival by Laboratory Data (Blood)
#### 7.3.2.1. Blood Gas
##### 7.3.2.1.1.    Blood Gas the Last Values

```{r Length of Survival by Laboratory Data (Blood Gas)}
labs_blood_gas_survival_last <- labs_blood_gas_combined_last %>%
  left_join(Survival_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL)) 

# Visualise each blood test parameter according to Survival Length

blood_test_params <- setdiff(names(labs_blood_gas_survival_last), c("SURVIVAL", "SURVIVAL_FLAG", "SUBJECT_ID_COMPOSE", "VENTILATOR"))

for (param in blood_test_params) {
  ggplot(labs_blood_gas_survival_last, aes(x = SURVIVAL, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs Survival Length"),
      x = "Survival Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal() -> p
  print(p)
}

rm(blood_test_params, p)
```

##### 7.3.2.1.2.    Blood Gas the Mean Values by Patient

```{r Length of Survival by Laboratory Data (Blood Gas Mean)}
labs_blood_gas_survival_mean <- labs_blood_gas_combined_mean %>%
  left_join(Survival_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL)) 

# Visualise each blood test parameter according to Survival Length

blood_test_params <- setdiff(names(labs_blood_gas_survival_mean), c("SURVIVAL", "SURVIVAL_FLAG", "SUBJECT_ID_COMPOSE", "VENTILATOR"))

for (param in blood_test_params) {
  ggplot(labs_blood_gas_survival_mean, aes(x = SURVIVAL, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs Survival Length"),
      x = "Survival Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal() -> p
  print(p)
}

rm(blood_test_params, p)
```

#### 7.3.2.2. Hematology
##### 7.3.2.2.1. Hematology the Last Values

```{r Length of Survival by Laboratory Data (Hematology last)}
hematology_survival_last <- hematology_combined_last %>%
  left_join(Survival_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL)) 

# Visualise each blood test parameter according to Survival Length

blood_test_params <- setdiff(names(hematology_survival_last), c("SURVIVAL", "SURVIVAL_FLAG", "SUBJECT_ID_COMPOSE", "VISIT_NUM"))

for (param in blood_test_params) {
  ggplot(hematology_survival_last, aes(x = SURVIVAL, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs Survival Length"),
      x = "Survival Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal() -> p
  print(p)
}

rm(blood_test_params, p)
```

##### 7.3.2.2.1. Hematology the Mean Values by Patient

```{r Length of Survival by Laboratory Data (Hematology mean)}
hematology_survival_mean <- hematology_combined_mean %>%
  left_join(Survival_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL)) 

# Visualise each blood test parameter according to Survival Length

blood_test_params <- setdiff(names(hematology_survival_mean), c("SURVIVAL", "SURVIVAL_FLAG", "SUBJECT_ID_COMPOSE"))

for (param in blood_test_params) {
  ggplot(hematology_survival_mean, aes(x = SURVIVAL, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs Survival Length"),
      x = "Survival Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal() -> p
  print(p)
}

rm(blood_test_params, p)
```

#### 7.3.2.3. Blood Chemistry
##### 7.3.2.3.1. Blood Chemistry the Last Values

```{r Length of Survival by Laboratory Data (Chemistry Last)}
chemistry_survival_last <- chemistry_combined_last %>%
  left_join(Survival_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL)) 

# Visualise each blood test parameter according to Survival Length

blood_test_params <- setdiff(names(chemistry_survival_last), c("SURVIVAL", "SURVIVAL_FLAG", "SUBJECT_ID_COMPOSE", "VISIT_NUM"))

for (param in blood_test_params) {
  ggplot(chemistry_survival_last, aes(x = SURVIVAL, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs Survival Length"),
      x = "Survival Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal() -> p
  print(p)
}

rm(blood_test_params, p)
```

##### 7.3.2.3.2. Blood Chemistry the Mean Values by Patients

```{r Length of Survival by Laboratory Data (Chemistry mean)}
chemistry_survival_mean <- chemistry_combined_mean %>%
  left_join(Survival_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID) %>%
  filter(!is.na(SURVIVAL)) 

# Visualise each blood test parameter according to ICU Stay Length
blood_test_params <- setdiff(names(chemistry_survival_mean), c("SURVIVAL", "SURVIVAL_FLAG", "SUBJECT_ID_COMPOSE", "VISIT_NUM"))

for (param in blood_test_params) {
  ggplot(chemistry_survival_mean, aes(x = SURVIVAL, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs Survival Length"),
      x = "Survival Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal() -> p
  print(p)
}

rm(blood_test_params, p)
```

### 7.3.3. Outcome 3: Length of ICU Stay by Laboratory Data (Blood)
#### 7.3.3.1. Blood Gas
##### 7.3.3.1.1.    Blood Gas the Last Values

```{r Length of ICU stay by Laboratory Data (Blood Gas last)}
labs_blood_gas_LOS_last <- labs_blood_gas_combined_last %>%
  left_join(LOS_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Visualise each blood test parameter according to ICU stay

blood_test_params <- setdiff(names(labs_blood_gas_LOS_last), c("LOS", "SUBJECT_ID_COMPOSE", "VENTILATOR", "ICUSTAY_ID"))

for (param in blood_test_params) {
  p <- ggplot(labs_blood_gas_LOS_last, aes(x = LOS, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, " (last values) vs ICU stay length"),
      x = "ICU Stay Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal()
  print(p)
}

rm(blood_test_params, p)
```

##### 7.3.3.1.2.    Blood Gas the Mean Values by Patient

```{r Length of ICU stay by Laboratory Data (Blood Gas mean)}
labs_blood_gas_LOS_mean <- labs_blood_gas_combined_mean %>%
  left_join(LOS_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Visualise each blood test parameter according to ICU stay

blood_test_params <- setdiff(names(labs_blood_gas_LOS_mean), c("LOS", "SUBJECT_ID_COMPOSE", "VENTILATOR", "ICUSTAY_ID"))

for (param in blood_test_params) {
  p <- ggplot(labs_blood_gas_LOS_mean, aes(x = LOS, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "(mean values) vs ICU stay length"),
      x = "ICU Stay Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal()
  print(p)
}

rm(blood_test_params, p)
```

#### 7.3.3.2. Hematology
##### 7.3.3.2.1. Hematology the Last Values

```{r Length of ICU stay by Laboratory Data (Hematology last)}
hematology_LOS_last <- hematology_combined_last %>%
  left_join(LOS_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Visualise each blood test parameter according to ICU stay

blood_test_params <- setdiff(names(hematology_LOS_last), c("LOS", "SUBJECT_ID_COMPOSE", "VISIT_NUM", "ICUSTAY_ID"))

for (param in blood_test_params) {
  p <- ggplot(hematology_LOS_last, aes(x = LOS, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs ICU stay length"),
      x = "ICU Stay Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal()
  print(p)
}

rm(blood_test_params, p)
```

##### 7.3.3.2.2. Hematology the Mean Values by Patient

```{r Length of ICU stay by Laboratory Data (Hematology mean)}
hematology_LOS_mean <- hematology_combined_mean %>%
  left_join(LOS_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Visualise each blood test parameter according to ICU stay

blood_test_params <- setdiff(names(hematology_LOS_mean), c("LOS", "SUBJECT_ID_COMPOSE", "VISIT_NUM", "ICUSTAY_ID"))

for (param in blood_test_params) {
  p <- ggplot(hematology_LOS_mean, aes(x = LOS, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs ICU stay length"),
      x = "ICU Stay Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal()
  print(p)
}

rm(blood_test_params, p)
```

#### 7.3.3.3. Blood Chemistry
##### 7.3.3.3.1. Blood Chemistry the Last Values

```{r Length of ICU stay by Laboratory Data (Chemistry Last)}
chemistry_LOS_last <- chemistry_combined_last %>%
  left_join(LOS_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Visualise each blood test parameter according to ICU stay
blood_test_params <- setdiff(names(chemistry_LOS_last), c("LOS", "SUBJECT_ID_COMPOSE", "ICUSTAY_ID"))

for (param in blood_test_params) {
  p <- ggplot(chemistry_LOS_last, aes(x = LOS, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs ICU stay length"),
      x = "ICU Stay Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal()
  print(p)
}

rm(blood_test_params, p)
```

##### 7.3.3.3.2. Blood Chemistry the Mean Values by Patient

```{r Length of ICU stay by Laboratory Data (Chemistry Mean)}
chemistry_LOS_mean <- chemistry_combined_mean %>%
  left_join(LOS_outcome, by = "SUBJECT_ID_COMPOSE") %>%
  select(-SUBJECT_ID)

# Visualise each blood test parameter according to ICU stay
blood_test_params <- setdiff(names(chemistry_LOS_mean), c("LOS", "SUBJECT_ID_COMPOSE", "ICUSTAY_ID"))

for (param in blood_test_params) {
  p <- ggplot(chemistry_LOS_mean, aes(x = LOS, y = .data[[param]])) +
    stat_bin2d(bins = 50) +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(
      title = paste("Density Heatmap of", param, "vs ICU stay length"),
      x = "ICU Stay Length (Days)",
      y = param,
      fill = "Count"
    ) +
    theme_minimal()
  print(p)
}

rm(blood_test_params, p)
```

## 7.4. Exploratory Analysis
### 7.4.1. Outcome 1: Death Status by Laboratory Data (Blood)
#### 7.4.1.1. Blood Gas
##### 7.4.1.1.1. Blood Gas the Last Values 

```{r Death Status by Laboratory Data (Blood) Blood Gas Last correlation matrix}

# Assuming `labs_blood_gas_death_outcome` contains numeric data and non-numeric columns to be excluded
correlation_data <- labs_blood_gas_death_outcome_last %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,  
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)
```

Predictors like contain nearly identical information:
- Hemoglobin and Hematocrit, calculated correlation is equal to 1 and will be analysed in Hematology data
- ALVEOLAR-ARTERIAL GRADIENT and Required O2 calculated correlation is equal to -0.92

 Multicollinearity can lead to unstable or unreliable coefficient estimates.
 
Predictors to remove: Hematocrit, Required O2.

```{r Death Status by Laboratory Data (Blood) Blood Gas Last linear regression}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "BASE_EXCESS", "ALVEOLAR_ARTERIAL_GRADIENT", "CALCULATED_TOTAL_CO2", "FREE_CALCIUM", "LACTATE", "PCO2", "PH", "PO2", "POTASSIUM_WHOLE_BLOOD", "SODIUM_WHOLE_BLOOD", "CHLORIDE_WHOLE_BLOOD", "PEEP", "TEMPERATURE", "OXYGEN", "OXYGEN_SATURATION", "TIDAL_VOLUME", "VENTILATION_RATE", "CALCULATED_BICARBONATE_WHOLE_BLOOD", "O2_FLOW", "METHEMOGLOBIN", "CARBOXYHEMOGLOBIN")

# Prepare a list to store ROC results
roc_results <- list()

# Calculate ROC for each predictor and store results
for (predictor in predictors) {
  roc_obj <- roc(
    labs_blood_gas_death_outcome_last$SURVIVAL_FLAG,
    labs_blood_gas_death_outcome_last[[predictor]],
    plot = FALSE
  )
  roc_results[[predictor]] <- roc_obj
}

# Extract data for ggplot
roc_data <- do.call(rbind, lapply(names(roc_results), function(predictor) {
  roc_curve <- roc_results[[predictor]]
  data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities,
    Predictor = predictor
  )
}))

# Combine AUC values for annotation
auc_values <- sapply(roc_results, function(x) auc(x))
auc_annotation <- paste(names(auc_values), round(auc_values, 2), sep = ": ", collapse = ", ")

# Generate individual ROC plots for each predictor
for (predictor in names(roc_results)) {
  # Extract ROC data for the predictor
  roc_curve <- roc_results[[predictor]]
  auc_value <- round(auc(roc_curve), 3)
  
  # Prepare data for plotting
  roc_data <- data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities
  )
  
  # Create the ROC plot for the current predictor
  roc_plot <- ggplot(roc_data, aes(x = 1 - Specificity, y = Sensitivity)) +
    geom_line(color = "pink", size = 1.2) +
    labs(
      title = paste("ROC Curve for", predictor),
      subtitle = paste("AUC =", auc_value),
      x = "1 - Specificity",
      y = "Sensitivity"
    ) +
    theme_minimal()
  
  # Print the plot for the current predictor
  print(roc_plot)
}

# Categorize AUC interpretation based on performance
auc_interpretation <- function(auc) {
  if (auc >= 0.9) {
    return("Outstanding")
  } else if (auc >= 0.8) {
    return("Excellent")
  } else if (auc >= 0.7) {
    return("Acceptable")
  } else if (auc >= 0.6) {
    return("Poor")
  } else {
    return("No Discrimination")
  }
}

# Add interpretation to the AUC table
auc_table <- data.frame(
  Predictor = names(auc_values),
  AUC = round(auc_values, 3),
  Interpretation = sapply(auc_values, auc_interpretation)
)

# Print the table in the console
print_table(auc_table)

rm(auc_table, auc_interpretation, auc_values, auc_annotation, roc_data, roc_results, predictors, roc_curve, roc_obj, roc_plot)
```


```{r Death Status by Laboratory Data (Blood) Blood Gas stat test}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "BASE_EXCESS", "ALVEOLAR_ARTERIAL_GRADIENT", "CALCULATED_TOTAL_CO2", "FREE_CALCIUM", "LACTATE", "PCO2", "PH", "PO2", "POTASSIUM_WHOLE_BLOOD", "SODIUM_WHOLE_BLOOD", "CHLORIDE_WHOLE_BLOOD", "PEEP", "TEMPERATURE", "OXYGEN", "OXYGEN_SATURATION", "TIDAL_VOLUME", "VENTILATION_RATE", "CALCULATED_BICARBONATE_WHOLE_BLOOD", "O2_FLOW", "METHEMOGLOBIN", "CARBOXYHEMOGLOBIN")

# Initialize an empty list to store results
result <- list()

labs_blood_gas_death_outcome_last <- labs_blood_gas_death_outcome_last %>%
  mutate(
    SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG)
  )

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- perform_statistical_tests(labs_blood_gas_death_outcome_last, "SURVIVAL_FLAG", predictor, predictor)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}

# Combine all results into a single data frame
final_result <- do.call(rbind, result)

# Print the final results
print_table(final_result)

rm(final_result, predictors, test_result, auc_value, param, predictor)
```

##### 7.4.1.1.2. Blood Gas the Mean Values by Patient

```{r Death Status by Laboratory Data (Blood) Blood Gas Mean correlation matrix}

# Assuming `labs_blood_gas_death_outcome` contains numeric data and non-numeric columns to be excluded
correlation_data <- labs_blood_gas_death_outcome_mean %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,  
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)
```

Predictors like contain nearly identical information:
- Hemoglobin and Hematocrit, calculated correlation is equal to 1 and will be analysed in Hematology data
- ALVEOLAR-ARTERIAL GRADIENT and Required O2 calculated correlation is equal to -0.92

 Multicollinearity can lead to unstable or unreliable coefficient estimates.
 
Predictors to remove: Hematocrit, Required O2.

```{r Death Status by Laboratory Data (Blood) Blood Gas Mean Last linear regression}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "BASE_EXCESS", "ALVEOLAR_ARTERIAL_GRADIENT", "CALCULATED_TOTAL_CO2", "FREE_CALCIUM", "LACTATE", "PCO2", "PH", "PO2", "POTASSIUM_WHOLE_BLOOD", "SODIUM_WHOLE_BLOOD", "CHLORIDE_WHOLE_BLOOD", "PEEP", "TEMPERATURE", "OXYGEN", "OXYGEN_SATURATION", "TIDAL_VOLUME", "VENTILATION_RATE", "CALCULATED_BICARBONATE_WHOLE_BLOOD", "O2_FLOW", "METHEMOGLOBIN", "CARBOXYHEMOGLOBIN")

# Prepare a list to store ROC results
roc_results <- list()

# Calculate ROC for each predictor and store results
for (predictor in predictors) {
  roc_obj <- roc(
    labs_blood_gas_death_outcome_mean$SURVIVAL_FLAG,
    labs_blood_gas_death_outcome_mean[[predictor]],
    plot = FALSE
  )
  roc_results[[predictor]] <- roc_obj
}

# Extract data for ggplot
roc_data <- do.call(rbind, lapply(names(roc_results), function(predictor) {
  roc_curve <- roc_results[[predictor]]
  data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities,
    Predictor = predictor
  )
}))

# Combine AUC values for annotation
auc_values <- sapply(roc_results, function(x) auc(x))
auc_annotation <- paste(names(auc_values), round(auc_values, 2), sep = ": ", collapse = ", ")

# Generate individual ROC plots for each predictor
for (predictor in names(roc_results)) {
  # Extract ROC data for the predictor
  roc_curve <- roc_results[[predictor]]
  auc_value <- round(auc(roc_curve), 3)
  
  # Prepare data for plotting
  roc_data <- data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities
  )
  
  # Create the ROC plot for the current predictor
  roc_plot <- ggplot(roc_data, aes(x = 1 - Specificity, y = Sensitivity)) +
    geom_line(color = "pink", size = 1.2) +
    labs(
      title = paste("ROC Curve for", predictor),
      subtitle = paste("AUC =", auc_value),
      x = "1 - Specificity",
      y = "Sensitivity"
    ) +
    theme_minimal()
  
  # Print the plot for the current predictor
  print(roc_plot)
}

# Categorize AUC interpretation based on performance
auc_interpretation <- function(auc) {
  if (auc >= 0.9) {
    return("Outstanding")
  } else if (auc >= 0.8) {
    return("Excellent")
  } else if (auc >= 0.7) {
    return("Acceptable")
  } else if (auc >= 0.6) {
    return("Poor")
  } else {
    return("No Discrimination")
  }
}

# Add interpretation to the AUC table
auc_table <- data.frame(
  Predictor = names(auc_values),
  AUC = round(auc_values, 3),
  Interpretation = sapply(auc_values, auc_interpretation)
)

# Print the table in the console
print_table(auc_table)

rm(auc_table, auc_interpretation, auc_values, auc_annotation, roc_data, roc_results, predictors, roc_curve, roc_obj, roc_plot)
```


```{r Death Status by Laboratory Data (Blood) Blood Gas Mean stat test}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "BASE_EXCESS", "ALVEOLAR_ARTERIAL_GRADIENT", "CALCULATED_TOTAL_CO2", "FREE_CALCIUM", "LACTATE", "PCO2", "PH", "PO2", "POTASSIUM_WHOLE_BLOOD", "SODIUM_WHOLE_BLOOD", "CHLORIDE_WHOLE_BLOOD", "PEEP", "TEMPERATURE", "OXYGEN", "OXYGEN_SATURATION", "TIDAL_VOLUME", "VENTILATION_RATE", "CALCULATED_BICARBONATE_WHOLE_BLOOD", "O2_FLOW", "METHEMOGLOBIN", "CARBOXYHEMOGLOBIN")

# Initialize an empty list to store results
result <- list()

labs_blood_gas_death_outcome_mean <- labs_blood_gas_death_outcome_mean %>%
  mutate(
    SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG)
  )

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- perform_statistical_tests(labs_blood_gas_death_outcome_mean, "SURVIVAL_FLAG", predictor, predictor)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}

# Combine all results into a single data frame
final_result <- do.call(rbind, result)

# Print the final results
print_table(final_result)

rm(final_result, predictors, test_result, auc_value, param, predictor)
```

#### 7.4.1.2. Hematology
##### 7.4.1.2.1.    Hematology the Last Values

```{r Death Status by Laboratory Data (Blood) Hematology last correlation matrix}

# Assuming `labs_blood_gas_death_outcome` contains numeric data and non-numeric columns to be excluded
correlation_data <- hematology_death_outcome_last %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,  
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)
```

Predictors like contain nearly identical information:
- Hemoglobin and Hematocrit , calculated correlation is equal to 0.95

 Multicollinearity can lead to unstable or unreliable coefficient estimates.
 
Predictors to remove: Hematocrit, RED_BLOOD_CELLS, PT.

```{r Death Status by Laboratory Data (Blood) Hematology last linear regression}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "RED_BLOOD_CELLS", "INR_PT", "LYMPHOCYTES", "MCH", "MCHC", "MCV", "MONOCYTES", "NEUTROPHILS", "EOSINOPHILS", "PLATELET_COUNT", "PTT", "PT", "RDW", "WHITE_BLOOD_CELLS", "FIBRINOGEN_FUNCTIONAL", "BASOPHILS", "SEDIMENTATION_RATE", "RETICULOCYTE_COUNT_AUTOMATED", "D_DIMER")

# Prepare a list to store ROC results
roc_results <- list()

# Calculate ROC for each predictor and store results
for (predictor in predictors) {
  roc_obj <- roc(
    hematology_death_outcome_last$SURVIVAL_FLAG,
    hematology_death_outcome_last[[predictor]],
    plot = FALSE
  )
  roc_results[[predictor]] <- roc_obj
}

# Extract data for ggplot
roc_data <- do.call(rbind, lapply(names(roc_results), function(predictor) {
  roc_curve <- roc_results[[predictor]]
  data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities,
    Predictor = predictor
  )
}))

# Combine AUC values for annotation
auc_values <- sapply(roc_results, function(x) auc(x))
auc_annotation <- paste(names(auc_values), round(auc_values, 2), sep = ": ", collapse = ", ")

# Generate individual ROC plots for each predictor
for (predictor in names(roc_results)) {
  # Extract ROC data for the predictor
  roc_curve <- roc_results[[predictor]]
  auc_value <- round(auc(roc_curve), 3)
  
  # Prepare data for plotting
  roc_data <- data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities
  )
  
  # Create the ROC plot for the current predictor
  roc_plot <- ggplot(roc_data, aes(x = 1 - Specificity, y = Sensitivity)) +
    geom_line(color = "pink", size = 1.2) +
    labs(
      title = paste("ROC Curve for", predictor),
      subtitle = paste("AUC =", auc_value),
      x = "1 - Specificity",
      y = "Sensitivity"
    ) +
    theme_minimal()
  
  # Print the plot for the current predictor
  print(roc_plot)
}

# Categorize AUC interpretation based on performance
auc_interpretation <- function(auc) {
  if (auc >= 0.9) {
    return("Outstanding")
  } else if (auc >= 0.8) {
    return("Excellent")
  } else if (auc >= 0.7) {
    return("Acceptable")
  } else if (auc >= 0.6) {
    return("Poor")
  } else {
    return("No Discrimination")
  }
}

# Add interpretation to the AUC table
auc_table <- data.frame(
  Predictor = names(auc_values),
  AUC = round(auc_values, 3),
  Interpretation = sapply(auc_values, auc_interpretation)
)

# Print the table in the console
print_table(auc_table)

rm(auc_table, auc_interpretation, auc_values, auc_annotation, roc_data, roc_results, predictors, roc_curve, roc_obj, roc_plot)
```

In the provided table, the following predictors should be included in future modeling:
INR_PT: AUC = 0.643
LYMPHOCYTES: AUC = 0.648
PTT: AUC = 0.606
PTT: AUC = 0.639
RDW: AUC = 0.653
WHITE_BLOOD_CELLS: AUC = 0.606

```{r Death Status by Laboratory Data (Blood) Hematology last stat test}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "RED_BLOOD_CELLS", "INR_PT", "LYMPHOCYTES", "MCH", "MCHC", "MCV", "MONOCYTES", "NEUTROPHILS", "EOSINOPHILS", "PLATELET_COUNT", "PTT", "PT", "RDW", "WHITE_BLOOD_CELLS", "FIBRINOGEN_FUNCTIONAL", "BASOPHILS", "SEDIMENTATION_RATE", "RETICULOCYTE_COUNT_AUTOMATED", "D_DIMER")

# Initialize an empty list to store results
result <- list()

hematology_death_outcome_last <- hematology_death_outcome_last %>%
  mutate(
    SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG)
  )

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- perform_statistical_tests(hematology_death_outcome_last, "SURVIVAL_FLAG", predictor, predictor)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}

# Combine all results into a single data frame
final_result <- do.call(rbind, result)

# Print the final results
print_table(final_result)

rm(final_result, predictors, test_result, auc_value, param, predictor)
```

##### 7.4.1.2.1.    Hematology the Mean Values by Patient

```{r Death Status by Laboratory Data (Blood) Hematology mean correlation matrix}

# Assuming `labs_blood_gas_death_outcome` contains numeric data and non-numeric columns to be excluded
correlation_data <- hematology_death_outcome_mean %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,  
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)
```

Predictors like contain nearly identical information:
- Hemoglobin and Hematocrit , calculated correlation is equal to 0.94

 Multicollinearity can lead to unstable or unreliable coefficient estimates.
 
Predictors to remove: Hematocrit.

```{r Death Status by Laboratory Data (Blood) Hematology mean linear regression}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "RED_BLOOD_CELLS", "INR_PT", "LYMPHOCYTES", "MCH", "MCHC", "MCV", "MONOCYTES", "NEUTROPHILS", "EOSINOPHILS", "PLATELET_COUNT", "PTT", "PT", "RDW", "WHITE_BLOOD_CELLS", "FIBRINOGEN_FUNCTIONAL", "BASOPHILS", "SEDIMENTATION_RATE", "RETICULOCYTE_COUNT_AUTOMATED", "D_DIMER")

# Prepare a list to store ROC results
roc_results <- list()

# Calculate ROC for each predictor and store results
for (predictor in predictors) {
  roc_obj <- roc(
    hematology_death_outcome_mean$SURVIVAL_FLAG,
    hematology_death_outcome_mean[[predictor]],
    plot = FALSE
  )
  roc_results[[predictor]] <- roc_obj
}

# Extract data for ggplot
roc_data <- do.call(rbind, lapply(names(roc_results), function(predictor) {
  roc_curve <- roc_results[[predictor]]
  data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities,
    Predictor = predictor
  )
}))

# Combine AUC values for annotation
auc_values <- sapply(roc_results, function(x) auc(x))
auc_annotation <- paste(names(auc_values), round(auc_values, 2), sep = ": ", collapse = ", ")

# Generate individual ROC plots for each predictor
for (predictor in names(roc_results)) {
  # Extract ROC data for the predictor
  roc_curve <- roc_results[[predictor]]
  auc_value <- round(auc(roc_curve), 3)
  
  # Prepare data for plotting
  roc_data <- data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities
  )
  
  # Create the ROC plot for the current predictor
  roc_plot <- ggplot(roc_data, aes(x = 1 - Specificity, y = Sensitivity)) +
    geom_line(color = "pink", size = 1.2) +
    labs(
      title = paste("ROC Curve for", predictor),
      subtitle = paste("AUC =", auc_value),
      x = "1 - Specificity",
      y = "Sensitivity"
    ) +
    theme_minimal()
  
  # Print the plot for the current predictor
  print(roc_plot)
}

# Categorize AUC interpretation based on performance
auc_interpretation <- function(auc) {
  if (auc >= 0.9) {
    return("Outstanding")
  } else if (auc >= 0.8) {
    return("Excellent")
  } else if (auc >= 0.7) {
    return("Acceptable")
  } else if (auc >= 0.6) {
    return("Poor")
  } else {
    return("No Discrimination")
  }
}

# Add interpretation to the AUC table
auc_table <- data.frame(
  Predictor = names(auc_values),
  AUC = round(auc_values, 3),
  Interpretation = sapply(auc_values, auc_interpretation)
)

# Print the table in the console
print_table(auc_table)

rm(auc_table, auc_interpretation, auc_values, auc_annotation, roc_data, roc_results, predictors, roc_curve, roc_obj, roc_plot)
```

In the provided table, the following predictors should be included in future modeling:
INR_PT: AUC = 0.664
LYMPHOCYTES: AUC = 0.662
MCHC: AUC = 0.611
PTT: AUC = 0.62
PTT: AUC = 0.658
RDW: AUC = 0.660
WHITE_BLOOD_CELLS: AUC = 0.658

```{r Death Status by Laboratory Data (Blood) Hematology mean stat test}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "RED_BLOOD_CELLS", "INR_PT", "LYMPHOCYTES", "MCH", "MCHC", "MCV", "MONOCYTES", "NEUTROPHILS", "EOSINOPHILS", "PLATELET_COUNT", "PTT", "PT", "RDW", "WHITE_BLOOD_CELLS", "FIBRINOGEN_FUNCTIONAL", "BASOPHILS", "SEDIMENTATION_RATE", "RETICULOCYTE_COUNT_AUTOMATED", "D_DIMER")

# Initialize an empty list to store results
result <- list()

hematology_death_outcome_mean <- hematology_death_outcome_mean %>%
  mutate(
    SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG)
  )

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- perform_statistical_tests(hematology_death_outcome_mean, "SURVIVAL_FLAG", predictor, predictor)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}

# Combine all results into a single data frame
final_result <- do.call(rbind, result)

# Print the final results
print_table(final_result)

rm(final_result, predictors, test_result, auc_value, param, predictor)
```

#### 7.4.1.3. Blood Chemistry
##### 7.4.1.3.1. Blood Chemistry the Last Values

```{r Death Status by Laboratory Data (Blood) Chemistry last correlation matrix}

# Assuming `labs_blood_gas_death_outcome` contains numeric data and non-numeric columns to be excluded
correlation_data <- chemistry_death_outcome_last %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,  
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)
```

Predictors like contain nearly identical information:
- ALT and AST, calculated correlation is equal to 0.81
- AST and LD calculated correlation is equal to 0.75
- Chloride and Sodium calculated correlation is equal to 0.71

 Multicollinearity can lead to unstable or unreliable coefficient estimates, but removing any of these predictors could reduce the interpretability of model for clinicians. Each provides insights into different physiological mechanisms that are crucial for ICU survival.

```{r Death Status by Laboratory Data (Blood) Chemistry last linear regression}
# Define predictors to evaluate
predictors <- c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA_NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "ANION_GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM_TOTAL", 
                      "BILIRUBIN_TOTAL", 
                      "ALT", 
                      "AST", 
                      "CRP", 
                      "TROPONIN_T", 
                      "LD")

# Prepare a list to store ROC results
roc_results <- list()

# Calculate ROC for each predictor and store results
for (predictor in predictors) {
  roc_obj <- roc(
    chemistry_death_outcome_last$SURVIVAL_FLAG,
    chemistry_death_outcome_last[[predictor]],
    plot = FALSE
  )
  roc_results[[predictor]] <- roc_obj
}

# Extract data for ggplot
roc_data <- do.call(rbind, lapply(names(roc_results), function(predictor) {
  roc_curve <- roc_results[[predictor]]
  data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities,
    Predictor = predictor
  )
}))

# Combine AUC values for annotation
auc_values <- sapply(roc_results, function(x) auc(x))
auc_annotation <- paste(names(auc_values), round(auc_values, 2), sep = ": ", collapse = ", ")

# Generate individual ROC plots for each predictor
for (predictor in names(roc_results)) {
  # Extract ROC data for the predictor
  roc_curve <- roc_results[[predictor]]
  auc_value <- round(auc(roc_curve), 3)
  
  # Prepare data for plotting
  roc_data <- data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities
  )
  
  # Create the ROC plot for the current predictor
  roc_plot <- ggplot(roc_data, aes(x = 1 - Specificity, y = Sensitivity)) +
    geom_line(color = "pink", size = 1.2) +
    labs(
      title = paste("ROC Curve for", predictor),
      subtitle = paste("AUC =", auc_value),
      x = "1 - Specificity",
      y = "Sensitivity"
    ) +
    theme_minimal()
  
  # Print the plot for the current predictor
  print(roc_plot)
}

# Categorize AUC interpretation based on performance
auc_interpretation <- function(auc) {
  if (auc >= 0.9) {
    return("Outstanding")
  } else if (auc >= 0.8) {
    return("Excellent")
  } else if (auc >= 0.7) {
    return("Acceptable")
  } else if (auc >= 0.6) {
    return("Poor")
  } else {
    return("No Discrimination")
  }
}

# Add interpretation to the AUC table
auc_table <- data.frame(
  Predictor = names(auc_values),
  AUC = round(auc_values, 3),
  Interpretation = sapply(auc_values, auc_interpretation)
)

# Print the table in the console
print_table(auc_table)

rm(auc_table, auc_interpretation, auc_values, auc_annotation, roc_data, roc_results, predictors, roc_curve, roc_obj, roc_plot)
```

In the provided table, the following predictors should be included in future modeling:
CREATININE: AUC = 0.622
UREA_NITROGEN: AUC = 0.681
BICARBONATE: AUC = 0.618
ANION_GAP: AUC = 0.633
BILIRUBIN_TOTAL: AUC = 0.606
AST: AUC = 0.637
CRP: AUC = 0.625
LD: AUC = 0.674

```{r Death Status by Laboratory Data (Blood) Chemistry last stat test}
# Define predictors to evaluate
predictors <- c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA_NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "ANION_GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM_TOTAL", 
                      "BILIRUBIN_TOTAL", 
                      "ALT", 
                      "AST", 
                      "CRP", 
                      "TROPONIN_T", 
                      "LD")

# Initialize an empty list to store results
result <- list()

chemistry_death_outcome_last <- chemistry_death_outcome_last %>%
  mutate(
    SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG)
  )

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- perform_statistical_tests(chemistry_death_outcome_last, "SURVIVAL_FLAG", predictor, predictor)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}

# Combine all results into a single data frame
final_result <- do.call(rbind, result)

# Print the final results
print_table(final_result)

rm(final_result, predictors, test_result, auc_value, param, predictor)
```

##### 7.4.1.3.2. Blood Chemistry the Mean Values by Patient

```{r Death Status by Laboratory Data (Blood) Chemistry mean correlation matrix}

# Assuming `labs_blood_gas_death_outcome` contains numeric data and non-numeric columns to be excluded
correlation_data <- chemistry_death_outcome_mean %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,  
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)
```

Predictors like contain nearly identical information:
- ALT and AST, calculated correlation is equal to 0.81

 Multicollinearity can lead to unstable or unreliable coefficient estimates, but removing any of these predictors could reduce the interpretability of model for clinicians. Each provides insights into different physiological mechanisms that are crucial for ICU survival.

```{r Death Status by Laboratory Data (Blood) Chemistry mean linear regression}
# Define predictors to evaluate
predictors <- c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA_NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "ANION_GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM_TOTAL", 
                      "BILIRUBIN_TOTAL", 
                      "ALT", 
                      "AST", 
                      "CRP", 
                      "TROPONIN_T", 
                      "LD")

# Prepare a list to store ROC results
roc_results <- list()

# Calculate ROC for each predictor and store results
for (predictor in predictors) {
  roc_obj <- roc(
    chemistry_death_outcome_mean$SURVIVAL_FLAG,
    chemistry_death_outcome_mean[[predictor]],
    plot = FALSE
  )
  roc_results[[predictor]] <- roc_obj
}

# Extract data for ggplot
roc_data <- do.call(rbind, lapply(names(roc_results), function(predictor) {
  roc_curve <- roc_results[[predictor]]
  data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities,
    Predictor = predictor
  )
}))

# Combine AUC values for annotation
auc_values <- sapply(roc_results, function(x) auc(x))
auc_annotation <- paste(names(auc_values), round(auc_values, 2), sep = ": ", collapse = ", ")

# Generate individual ROC plots for each predictor
for (predictor in names(roc_results)) {
  # Extract ROC data for the predictor
  roc_curve <- roc_results[[predictor]]
  auc_value <- round(auc(roc_curve), 3)
  
  # Prepare data for plotting
  roc_data <- data.frame(
    Sensitivity = roc_curve$sensitivities,
    Specificity = roc_curve$specificities
  )
  
  # Create the ROC plot for the current predictor
  roc_plot <- ggplot(roc_data, aes(x = 1 - Specificity, y = Sensitivity)) +
    geom_line(color = "pink", size = 1.2) +
    labs(
      title = paste("ROC Curve for", predictor),
      subtitle = paste("AUC =", auc_value),
      x = "1 - Specificity",
      y = "Sensitivity"
    ) +
    theme_minimal()
  
  # Print the plot for the current predictor
  print(roc_plot)
}

# Categorize AUC interpretation based on performance
auc_interpretation <- function(auc) {
  if (auc >= 0.9) {
    return("Outstanding")
  } else if (auc >= 0.8) {
    return("Excellent")
  } else if (auc >= 0.7) {
    return("Acceptable")
  } else if (auc >= 0.6) {
    return("Poor")
  } else {
    return("No Discrimination")
  }
}

# Add interpretation to the AUC table
auc_table <- data.frame(
  Predictor = names(auc_values),
  AUC = round(auc_values, 3),
  Interpretation = sapply(auc_values, auc_interpretation)
)

# Print the table in the console
print_table(auc_table)

rm(auc_table, auc_interpretation, auc_values, auc_annotation, roc_data, roc_results, predictors, roc_curve, roc_obj, roc_plot)
```

In the provided table, the following predictors should be included in future modeling:
CREATININE: AUC = 0.653
UREA_NITROGEN: AUC = 0.720
BICARBONATE: AUC = 0.657
ANION_GAP: AUC = 0.709
PHOSPHATE: AUC = 0.627
BILIRUBIN_TOTAL: AUC = 0.623
AST: AUC = 0.602
CRP: AUC = 0.664
LD: AUC = 0.695

```{r Death Status by Laboratory Data (Blood) Chemistry mean stat test}
# Define predictors to evaluate
predictors <- c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA_NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "ANION_GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM_TOTAL", 
                      "BILIRUBIN_TOTAL", 
                      "ALT", 
                      "AST", 
                      "CRP", 
                      "TROPONIN_T", 
                      "LD")

# Initialize an empty list to store results
result <- list()

chemistry_death_outcome_mean <- chemistry_death_outcome_mean %>%
  mutate(
    SURVIVAL_FLAG = as.factor(SURVIVAL_FLAG)
  )

# Loop through each predictor
for (predictor in predictors) {
  # Perform the statistical test
  test_result <- perform_statistical_tests(chemistry_death_outcome_mean, "SURVIVAL_FLAG", predictor, predictor)
  
  # Append the result to the list
  result[[predictor]] <- test_result
}

# Combine all results into a single data frame
final_result <- do.call(rbind, result)

# Print the final results
print_table(final_result)

rm(final_result, predictors, test_result, auc_value, param, predictor)
```

### 7.4.2. Outcome 2: Length of Survival by Laboratory Data (Blood)
#### 7.4.2.1. Blood Gas
##### 7.4.2.1.1. Blood Gas the Last Value

```{r Length of Survival  by Laboratory Data (Blood) Blood Gas Last correlation matrix}
# Assuming `labs_blood_gas_survival` contains numeric data and non-numeric columns to be excluded
correlation_data <- labs_blood_gas_survival_last %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix, result)
```

No correlations with Survival Length were identified.

```{r Length of Survival  by Laboratory Data (Blood) Blood Gas Mean HR }

# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "BASE_EXCESS", "ALVEOLAR_ARTERIAL_GRADIENT", "CALCULATED_TOTAL_CO2", "FREE_CALCIUM", "LACTATE", "PCO2", "PH", "PO2", "POTASSIUM_WHOLE_BLOOD", "SODIUM_WHOLE_BLOOD", "CHLORIDE_WHOLE_BLOOD", "PEEP", "TEMPERATURE", "OXYGEN", "OXYGEN_SATURATION", "TIDAL_VOLUME", "VENTILATION_RATE", "CALCULATED_BICARBONATE_WHOLE_BLOOD", "O2_FLOW", "METHEMOGLOBIN", "CARBOXYHEMOGLOBIN")

# Initialize an empty list to store results
hr_results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform Hazard Ratio (HR) assessment for the current predictor
  hr_result <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", predictor, labs_blood_gas_survival_last)
  
  # Append the result to the list
  hr_results[[predictor]] <- hr_result
}

# Combine all results into a single data frame
hr_table <- do.call(rbind, lapply(names(hr_results), function(predictor) {
  cbind(Predictor = predictor, hr_results[[predictor]])
}))

# Convert to data frame for better formatting
hr_table <- as.data.frame(hr_table)

# Print the final HR table
print_table(hr_table)

rm(predictors, hr_results, hr_table, labs_blood_gas_survival_last, hr_result)
```

##### 7.4.2.1.1. Blood Gas the Last Value

```{r Length of Survival  by Laboratory Data (Blood) Blood Gas Mean correlation matrix}
# Assuming `labs_blood_gas_survival` contains numeric data and non-numeric columns to be excluded
correlation_data <- labs_blood_gas_survival_mean %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix, result)
```

No correlations with Survival Length were identified.

```{r Length of Survival  by Laboratory Data (Blood) Blood Gas Last HR }

# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "BASE_EXCESS", "ALVEOLAR_ARTERIAL_GRADIENT", "CALCULATED_TOTAL_CO2", "FREE_CALCIUM", "LACTATE", "PCO2", "PH", "PO2", "POTASSIUM_WHOLE_BLOOD", "SODIUM_WHOLE_BLOOD", "CHLORIDE_WHOLE_BLOOD", "PEEP", "TEMPERATURE", "OXYGEN", "OXYGEN_SATURATION", "TIDAL_VOLUME", "VENTILATION_RATE", "CALCULATED_BICARBONATE_WHOLE_BLOOD", "O2_FLOW", "METHEMOGLOBIN", "CARBOXYHEMOGLOBIN")

# Initialize an empty list to store results
hr_results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform Hazard Ratio (HR) assessment for the current predictor
  hr_result <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", predictor, labs_blood_gas_survival_mean)
  
  # Append the result to the list
  hr_results[[predictor]] <- hr_result
}

# Combine all results into a single data frame
hr_table <- do.call(rbind, lapply(names(hr_results), function(predictor) {
  cbind(Predictor = predictor, hr_results[[predictor]])
}))

# Convert to data frame for better formatting
hr_table <- as.data.frame(hr_table)

# Print the final HR table
print_table(hr_table)

rm(predictors, hr_results, hr_table, labs_blood_gas_survival_mean, hr_result)
```

#### 7.4.2.2. Hematology
##### 7.4.2.2.1. Hematology the Last Values

```{r Length of Survival  by Laboratory Data (Blood) Hematology last correlation matrix}
# Assuming `labs_blood_gas_survival` contains numeric data and non-numeric columns to be excluded
correlation_data <- hematology_survival_last %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix, result)
```

No correlation with Survival Length was found. 

```{r Length of Survival  by Laboratory Data (Blood) Hematology last HR }

# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "RED_BLOOD_CELLS", "INR_PT", "LYMPHOCYTES", "MCH", "MCHC", "MCV", "MONOCYTES", "NEUTROPHILS", "EOSINOPHILS", "PLATELET_COUNT", "PTT", "PT", "RDW", "WHITE_BLOOD_CELLS", "FIBRINOGEN_FUNCTIONAL", "BASOPHILS", "SEDIMENTATION_RATE", "RETICULOCYTE_COUNT_AUTOMATED", "D_DIMER")

# Initialize an empty list to store results
hr_results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform Hazard Ratio (HR) assessment for the current predictor
  hr_result <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", predictor, hematology_survival_last)
  
  # Append the result to the list
  hr_results[[predictor]] <- hr_result
}

# Combine all results into a single data frame
hr_table <- do.call(rbind, lapply(names(hr_results), function(predictor) {
  cbind(Predictor = predictor, hr_results[[predictor]])
}))

# Convert to data frame for better formatting
hr_table <- as.data.frame(hr_table)

# Print the final HR table
print_table(hr_table)

rm(predictors, hr_results, hr_table)
```

##### 7.4.2.2.1. Hematology the Mean Values by Patient

```{r Length of Survival  by Laboratory Data (Blood) Hematology mean correlation matrix}
# Assuming `labs_blood_gas_survival` contains numeric data and non-numeric columns to be excluded
correlation_data <- hematology_survival_mean %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix, result)
```

No correlation with Survival Length was found. 

```{r Length of Survival  by Laboratory Data (Blood) Hematology mean HR }

# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "RED_BLOOD_CELLS", "INR_PT", "LYMPHOCYTES", "MCH", "MCHC", "MCV", "MONOCYTES", "NEUTROPHILS", "EOSINOPHILS", "PLATELET_COUNT", "PTT", "PT", "RDW", "WHITE_BLOOD_CELLS", "FIBRINOGEN_FUNCTIONAL", "BASOPHILS", "SEDIMENTATION_RATE", "RETICULOCYTE_COUNT_AUTOMATED", "D_DIMER")

# Initialize an empty list to store results
hr_results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform Hazard Ratio (HR) assessment for the current predictor
  hr_result <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", predictor, hematology_survival_mean)
  
  # Append the result to the list
  hr_results[[predictor]] <- hr_result
}

# Combine all results into a single data frame
hr_table <- do.call(rbind, lapply(names(hr_results), function(predictor) {
  cbind(Predictor = predictor, hr_results[[predictor]])
}))

# Convert to data frame for better formatting
hr_table <- as.data.frame(hr_table)

# Print the final HR table
print_table(hr_table)

rm(predictors, hr_results, hr_table)
```

#### 7.4.2.3. Blood Chemistry
##### 7.4.2.3.1. Blood Chemistry the Last Values

```{r Length of Survival  by Laboratory Data (Blood) Chemistry last correlation matrix}
# Assuming `labs_blood_gas_survival` contains numeric data and non-numeric columns to be excluded
correlation_data <- chemistry_survival_last %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix, result)
```

No correlation with Survival Length was found. 

```{r Length of Survival  by Laboratory Data (Blood) Chemistry mean HR }

# Define predictors to evaluate
predictors <- c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA_NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "ANION_GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM_TOTAL", 
                      "BILIRUBIN_TOTAL", 
                      "ALT", 
                      "AST", 
                      "CRP", 
                      "TROPONIN_T", 
                      "LD")

# Initialize an empty list to store results
hr_results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform Hazard Ratio (HR) assessment for the current predictor
  hr_result <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", predictor, chemistry_survival_last)
  
  # Append the result to the list
  hr_results[[predictor]] <- hr_result
}

# Combine all results into a single data frame
hr_table <- do.call(rbind, lapply(names(hr_results), function(predictor) {
  cbind(Predictor = predictor, hr_results[[predictor]])
}))

# Convert to data frame for better formatting
hr_table <- as.data.frame(hr_table)

# Print the final HR table
print_table(hr_table)

rm(predictors, hr_results, hr_table)
```


##### 7.4.2.3.1. Blood Chemistry the Mean Values by Patient

```{r Length of Survival  by Laboratory Data (Blood) Chemistry mean correlation matrix}
# Assuming `labs_blood_gas_survival` contains numeric data and non-numeric columns to be excluded
correlation_data <- chemistry_survival_mean %>%
  select(where(is.numeric)) %>%
  select(-SURVIVAL_FLAG)

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix, result)
```

No correlation with Survival Length was found. 

```{r Length of Survival  by Laboratory Data (Blood) Chemistry last HR }

# Define predictors to evaluate
predictors <- c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA_NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "ANION_GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM_TOTAL", 
                      "BILIRUBIN_TOTAL", 
                      "ALT", 
                      "AST", 
                      "CRP", 
                      "TROPONIN_T", 
                      "LD")

# Initialize an empty list to store results
hr_results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform Hazard Ratio (HR) assessment for the current predictor
  hr_result <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", predictor, chemistry_survival_mean)
  
  # Append the result to the list
  hr_results[[predictor]] <- hr_result
}

# Combine all results into a single data frame
hr_table <- do.call(rbind, lapply(names(hr_results), function(predictor) {
  cbind(Predictor = predictor, hr_results[[predictor]])
}))

# Convert to data frame for better formatting
hr_table <- as.data.frame(hr_table)

# Print the final HR table
print_table(hr_table)

rm(predictors, hr_results, hr_table)
```

### 7.4.3. Outcome 3: ICU stay Length by Laboratory Data (Blood)
#### 7.4.3.1. Blood Gas
##### 7.4.3.1.1. Blood Gas the Last Value

```{r Length of ICU STAY length  by Laboratory Data (Blood) Blood Gas Last correlation matrix}
# Assuming `labs_blood_gas_LOS` contains numeric data and non-numeric columns to be excluded
correlation_data <- labs_blood_gas_LOS_last %>%
  select(where(is.numeric))

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)

```

No correlations with LOS was found.

```{r Death Status by Laboratory Data (Blood Gas) last stat tests}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "BASE_EXCESS", "ALVEOLAR_ARTERIAL_GRADIENT", "CALCULATED_TOTAL_CO2", "FREE_CALCIUM", "LACTATE", "PCO2", "PH", "PO2", "POTASSIUM_WHOLE_BLOOD", "SODIUM_WHOLE_BLOOD", "CHLORIDE_WHOLE_BLOOD", "PEEP", "TEMPERATURE", "OXYGEN", "OXYGEN_SATURATION", "TIDAL_VOLUME", "VENTILATION_RATE", "CALCULATED_BICARBONATE_WHOLE_BLOOD", "O2_FLOW", "METHEMOGLOBIN", "CARBOXYHEMOGLOBIN")
  
# Initialize an empty list to store results
results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform assessment for the current predictor
  result <- analyze_predictor_LOS(labs_blood_gas_LOS_last, predictor, LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
  
  # Append the result to the list
  results[[predictor]] <- result
}

# Combine all results into a single data frame
table <- do.call(rbind, lapply(names(results), function(predictor) {
  cbind(Predictor = predictor, results[[predictor]])
}))

# Convert to data frame for better formatting
table <- as.data.frame(table)

# Print the final HR table
print_table(table)

rm(table, results, predictors, predictor, labs_blood_gas_LOS_last, blood_gas, labs_blood_gas_combined)
```

##### 7.4.3.1.2. Blood Gas the Mean Value by Patient

```{r Length of ICU STAY length  by Laboratory Data (Blood) Blood Gas Mean correlation matrix}
# Assuming `labs_blood_gas_LOS` contains numeric data and non-numeric columns to be excluded
correlation_data <- labs_blood_gas_LOS_mean %>%
  select(where(is.numeric))

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)

```

No correlations with LOS was found.

```{r Death Status by Laboratory Data (Blood Gas) stat mean tests}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "BASE_EXCESS", "ALVEOLAR_ARTERIAL_GRADIENT", "CALCULATED_TOTAL_CO2", "FREE_CALCIUM", "LACTATE", "PCO2", "PH", "PO2", "POTASSIUM_WHOLE_BLOOD", "SODIUM_WHOLE_BLOOD", "CHLORIDE_WHOLE_BLOOD", "PEEP", "TEMPERATURE", "OXYGEN", "OXYGEN_SATURATION", "TIDAL_VOLUME", "VENTILATION_RATE", "CALCULATED_BICARBONATE_WHOLE_BLOOD", "O2_FLOW", "METHEMOGLOBIN", "CARBOXYHEMOGLOBIN")
  
# Initialize an empty list to store results
results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform assessment for the current predictor
  result <- analyze_predictor_LOS(labs_blood_gas_LOS_mean, predictor, LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
  
  # Append the result to the list
  results[[predictor]] <- result
}

# Combine all results into a single data frame
table <- do.call(rbind, lapply(names(results), function(predictor) {
  cbind(Predictor = predictor, results[[predictor]])
}))

# Convert to data frame for better formatting
table <- as.data.frame(table)

# Print the final HR table
print_table(table)

rm(table, results, predictors, predictor, labs_blood_gas_LOS_mean, blood_gas, labs_blood_gas_combined)
```

#### 7.4.3.2. Hematology
##### 7.4.3.2.1. Hematology the Last Values

```{r Length of ICU STAY length  by Laboratory Data (Blood) Hematology last correlation matrix}
# Assuming `hematology_LOS` contains numeric data and non-numeric columns to be excluded
correlation_data <- hematology_LOS_last %>%
  select(where(is.numeric))

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)

```

No correlations with LOS was found.

```{r Death Status by Laboratory Data Hematology last stat tests}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "RED_BLOOD_CELLS", "INR_PT", "LYMPHOCYTES", "MCH", "MCHC", "MCV", "MONOCYTES", "NEUTROPHILS", "EOSINOPHILS", "PLATELET_COUNT", "PTT", "PT", "RDW", "WHITE_BLOOD_CELLS", "FIBRINOGEN_FUNCTIONAL", "BASOPHILS", "SEDIMENTATION_RATE", "RETICULOCYTE_COUNT_AUTOMATED", "D_DIMER")
  
# Initialize an empty list to store results
results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform assessment for the current predictor
  result <- analyze_predictor_LOS(hematology_LOS_last, predictor, LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
  
  # Append the result to the list
  results[[predictor]] <- result
}

# Combine all results into a single data frame
table <- do.call(rbind, lapply(names(results), function(predictor) {
  cbind(Predictor = predictor, results[[predictor]])
}))

# Convert to data frame for better formatting
table <- as.data.frame(table)

# Print the final HR table
print_table(table)

rm(table, results, predictors, predictor)
```


##### 7.4.3.2.1. Hematology the Mean Values by patient

```{r Length of ICU STAY length  by Laboratory Data (Blood) Hematology mean correlation matrix}
# Assuming `hematology_LOS` contains numeric data and non-numeric columns to be excluded
correlation_data <- hematology_LOS_mean %>%
  select(where(is.numeric))

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)

```

No correlations with LOS was found.

```{r Death Status by Laboratory Data Hematology mean stat tests}
# Define predictors to evaluate
predictors <- c("HEMOGLOBIN", "RED_BLOOD_CELLS", "INR_PT", "LYMPHOCYTES", "MCH", "MCHC", "MCV", "MONOCYTES", "NEUTROPHILS", "EOSINOPHILS", "PLATELET_COUNT", "PTT", "PT", "RDW", "WHITE_BLOOD_CELLS", "FIBRINOGEN_FUNCTIONAL", "BASOPHILS", "SEDIMENTATION_RATE", "RETICULOCYTE_COUNT_AUTOMATED", "D_DIMER")
  
# Initialize an empty list to store results
results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform assessment for the current predictor
  result <- analyze_predictor_LOS(hematology_LOS_mean, predictor, LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
  
  # Append the result to the list
  results[[predictor]] <- result
}

# Combine all results into a single data frame
table <- do.call(rbind, lapply(names(results), function(predictor) {
  cbind(Predictor = predictor, results[[predictor]])
}))

# Convert to data frame for better formatting
table <- as.data.frame(table)

# Print the final HR table
print_table(table)

rm(table, results, predictors, predictor)
```

#### 7.4.3.3. Blood Chemistry
##### 7.4.3.3.1. Blood Chemistry the Last Values

```{r Length of ICU STAY length  by Laboratory Data (Blood) Chemistry last correlation matrix}
# Assuming `hematology_LOS` contains numeric data and non-numeric columns to be excluded
correlation_data <- chemistry_LOS_last %>%
  select(where(is.numeric)) 

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)

```

No correlations with LOS was found.

```{r Death Status by Laboratory Data Chemistry last stat tests}
# Define predictors to evaluate
predictors <- c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA_NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "ANION_GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM_TOTAL", 
                      "BILIRUBIN_TOTAL", 
                      "ALT", 
                      "AST", 
                      "CRP", 
                      "TROPONIN_T", 
                      "LD")
  
# Initialize an empty list to store results
results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform assessment for the current predictor
  result <- analyze_predictor_LOS(chemistry_LOS_last, predictor, LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
  
  # Append the result to the list
  results[[predictor]] <- result
}

# Combine all results into a single data frame
table <- do.call(rbind, lapply(names(results), function(predictor) {
  cbind(Predictor = predictor, results[[predictor]])
}))

# Convert to data frame for better formatting
table <- as.data.frame(table)

# Print the final HR table
print_table(table)

rm(table, results, predictors, predictor, chemistry_LOS_last)
```


##### 7.4.3.3.2. Blood Chemistry the Mean Values by Patient

```{r Length of ICU STAY length  by Laboratory Data (Blood) Chemistry mean correlation matrix}
# Assuming `hematology_LOS` contains numeric data and non-numeric columns to be excluded
correlation_data <- chemistry_LOS_mean %>%
  select(where(is.numeric)) 

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs", method = "pearson")

# Plot the correlation matrix
corrplot(correlation_matrix, 
         method = "color", 
         type = "upper", 
         tl.col = "black", 
         tl.srt = 45, 
         number.cex = 0.3,    # Smaller text size for numbers
         addCoef.col = "black", 
         mar = c(1, 1, 1, 1),
         cl.cex = 0.8,        
         tl.cex = 0.3)   

rm(correlation_data, correlation_matrix)

```

No correlations with LOS was found.

```{r Death Status by Laboratory Data Chemistry mean stat tests}
# Define predictors to evaluate
predictors <- c("POTASSIUM", 
                      "SODIUM", 
                      "CREATININE", 
                      "CHLORIDE", 
                      "UREA_NITROGEN", 
                      "BICARBONATE", 
                      "GLUCOSE", 
                      "ANION_GAP", 
                      "MAGNESIUM", 
                      "PHOSPHATE", 
                      "CALCIUM_TOTAL", 
                      "BILIRUBIN_TOTAL", 
                      "ALT", 
                      "AST", 
                      "CRP", 
                      "TROPONIN_T", 
                      "LD")
  
# Initialize an empty list to store results
results <- list()

# Loop through each predictor
for (predictor in predictors) {
  # Perform assessment for the current predictor
  result <- analyze_predictor_LOS(chemistry_LOS_mean, predictor, LOS = "LOS", patient_id = "SUBJECT_ID_COMPOSE")
  
  # Append the result to the list
  results[[predictor]] <- result
}

# Combine all results into a single data frame
table <- do.call(rbind, lapply(names(results), function(predictor) {
  cbind(Predictor = predictor, results[[predictor]])
}))

# Convert to data frame for better formatting
table <- as.data.frame(table)

# Print the final HR table
print_table(table)

rm(table, results, predictors, predictor, chemistry_LOS_mean)
```

# 8. Procedures Data
# 8.1. Read data

``` {r read data pocedures}
procedures <- read.csv("../data/raw/cleaned/PROCEDURES_clean.csv", stringsAsFactors = TRUE) %>%
  mutate(across(where(is.character), as.factor))  %>%
  filter(SUBJECT_ID %in% subject_ids_adults) %>%
  mutate(SUBJECT_ID = as.factor(SUBJECT_ID),
         ICUSTAY_ID = as.factor(ICUSTAY_ID))

skimr::skim(procedures %>%
              select(-SUBJECT_ID, -HADM_ID, -SUBJECT_ID_COMPOSE, -ICUSTAY_ID))
```

## 8.2. Desriptive Statistics
### 8.2.1. Descriptive Statistics for Numerical Variables (Procedures data)

```{r descriptive statistics for numerical vars procedures}
# Summarize the statistics for each numeric variable
procedures %>%
  select(SEQ_NUM) %>%
  select(where(is.numeric)) %>% 
  summarise(across(everything(), statistics)) %>%
  pivot_longer(cols = everything(), names_sep = "__", names_to = c("Variable", "Stat")) %>%
  rename(`Value` = value) %>%
  flextable() %>%
  merge_v("Variable") %>%
  width(j = c("Variable", "Stat", "Value"), width = 2) %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

### 8.2.2. Descriptive Statistics for Categorical Variables (Procedures data)

```{r Descriptive statistics for procedures for categorical vars}
# Clean and summarize the categorical data for all factor variables
procedures %>%
  select(LABEL, ORDERCATEGORYNAME) %>%
  select(where(is.factor)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  group_by(Variable, Value) %>%
  summarise(n = n(), .groups = 'drop') %>%
  group_by(Variable) %>%
  mutate(`No data` = sum(is.na(Value)),
         `% by group` = (n / sum(n)) * 100) %>%
  ungroup() %>%
  select(Variable, Value, n, `% by group`, `No data`) %>%
  arrange(Variable, desc(n)) %>%
  flextable() %>%
  merge_v("Variable") %>%
  autofit() %>%
  border_inner(border = fp_border(color = "black", width = 1)) %>%
  border_outer(border = fp_border(color = "black", width = 1))
```

Decided to focus on following procedures:

- CHEST X-RAY
- INVASIVE VENTILATION (min)
- EXTUBATION
- INTUBATION
- ARTERIAL LINE (min)
- MULTI LUMEN (min)
- DIALYSIS - CRRT (min)

## 8.3. Visualisation Analysis by Outcome
### 8.3.1. Outcome 1: Death Status by Procedures Data
#### 8.3.1.1. Procedures with duration

``` {r Outcome 1: Death Status by Procedures Data}

procedures_with_duration <- procedures %>%
  filter(LABEL %in% c("INVASIVE VENTILATION", 
                      "ARTERIAL LINE", 
                      "MULTI LUMEN", 
                      "DIALYSIS - CRRT")) %>%
  mutate(VALUE = as.numeric(VALUE)) %>%  # Ensure duration is numeric
  filter(!is.na(VALUE))  # Remove rows with missing durations

procedures_with_duration_death_outcome <- Death_status_outcome %>%
  left_join(procedures_with_duration, by = c("SUBJECT_ID", "SUBJECT_ID_COMPOSE")) %>%
  select(-SUBJECT_ID, -HADM_ID, -ICUSTAY_ID, -ITEMID, -VALUEUOM, -ORDERCATEGORYNAME, -STATUSDESCRIPTION, -SEQ_NUM)  # Remove redundant columns

ggplot(procedures_with_duration_death_outcome, aes(x = LABEL, y = VALUE, fill = factor(SURVIVAL_FLAG))) +
  geom_boxplot(outlier.color = color_palette[4], outlier.size = 2) +
  labs(
    title = "Distribution of Duration (in Minutes) by Predictors and Survival Flag",
    x = "Predictor",
    y = "Duration (Minutes)",
    fill = "Survival Flag"
  ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(procedures_with_duration_death_outcome$SURVIVAL_FLAG)), replace = FALSE),
    labels = c("0" = "Survived", "1" = "Died")
    ) +
  scale_y_continuous(
    labels = scales::comma  # Format y-axis with commas for better readability
  ) +
  theme_custom +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

ggplot(procedures_with_duration_death_outcome, aes(x = VALUE, fill = factor(SURVIVAL_FLAG))) +
  geom_density(alpha = 0.6) +
  facet_wrap(~ LABEL, scales = "free") +  # Separate density plots for each predictor
  labs(
    title = "Density Plot of Duration (in Minutes) by Survival Flag",
    x = "Duration (Minutes)",
    y = "Density",
    fill = "Survival Flag"
  ) +
  scale_fill_manual(
    values = sample(color_palette, size = length(unique(procedures_with_duration_death_outcome$SURVIVAL_FLAG)), replace = FALSE),
    labels = c("0" = "Survived", "1" = "Died")
    ) +
  scale_x_continuous(
    labels = scales::comma  # Format y-axis with commas for better readability
  ) +
  theme_custom +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

```

#### 8.3.1.2. Procedures without Duration

``` {r Death Status by Procedures Data Procedures without Duration}

procedures_binary <- procedures %>%
  filter(LABEL %in% c("CHEST X-RAY", "EXTUBATION", "INTUBATION")) %>%
  select(SUBJECT_ID_COMPOSE, LABEL, VALUE)

# Ensure all subjects have all required labels as columns
procedures_binary_death_outcome_flags <- Death_status_outcome %>%
  left_join(procedures_binary, by = "SUBJECT_ID_COMPOSE") %>%
  # Generate the required columns for each LABEL
  pivot_wider(
    names_from = LABEL,         # Create a column for each procedure (LABEL)
    values_from = LABEL,        # Use LABEL itself to check the condition
    values_fn = list(LABEL = ~ unique(.)), # Ensure one unique value per cell
    values_fill = NA            # Fill missing with NA for now
  ) %>%
  select(-VALUE, -`NA`) %>%
  # Replace NA with 0, otherwise set 1 in EXTUBATION, INTUBATION, and CHEST_X_RAY
  mutate(
    CHEST_X_RAY = if_else(is.na(`CHEST X-RAY`), 0, 1),
    EXTUBATION = if_else(is.na(EXTUBATION), 0, 1),
    INTUBATION = if_else(is.na(INTUBATION), 0, 1)
  ) %>%
  select(-`CHEST X-RAY`)
  
# Transform the data to long format for easier visualization
procedures_long <- procedures_binary_death_outcome_flags %>%
  pivot_longer(
    cols = c(CHEST_X_RAY, EXTUBATION, INTUBATION),  # Columns to reshape
    names_to = "Procedure",                        # New column for procedure names
    values_to = "Performed"                        # Binary flag: 0 or 1
  )

# Create a grouped bar plot
ggplot(procedures_long, aes(x = Procedure, fill = factor(Performed))) +
  geom_bar(position = "dodge", aes(y = ..count..), color = "black") +
  facet_wrap(~ SURVIVAL_FLAG, labeller = labeller(SURVIVAL_FLAG = c("0" = "Survived", "1" = "Died"))) +
  scale_fill_manual(
    values = c("0" = color_palette[3], "1" = color_palette[5]),
    labels = c("0" = "Not Performed", "1" = "Performed")
  ) +
  labs(
    title = "Distribution of Procedures by Survival Status",
    x = "Procedure",
    y = "Count",
    fill = "Performed"
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

### 8.3.2. Outcome 2: Length of Survival by Procedures Data
#### 8.3.2.1. Procedures with duration

```{r Length of Survival by Prescriptions Data Procedures with duration}
procedures_with_duration_survival_outcome <- Survival_outcome %>%
  left_join(procedures_with_duration, by = "SUBJECT_ID_COMPOSE")
  
ggplot(procedures_with_duration_survival_outcome, aes(x = LABEL, y = SURVIVAL, fill = LABEL)) +
  geom_boxplot(outlier.color = color_palette[8], outlier.size = 2, alpha = 0.6) +
  labs(
    title = "Distribution of Survival by Procedures with Duration",
    x = "Procedure",
    y = "Survival (Days)"
  ) +
  scale_fill_manual(values = sample(color_palette, size = length(unique(procedures_with_duration_survival_outcome$LABEL)), replace = FALSE)) +
  theme_custom +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )
  
```

#### 8.3.2.2. Procedures without Duration
```{r Length of Survival by Prescriptions Data Procedures without duration}

procedures_binary_survival_outcome_flags <- Survival_outcome %>%
  left_join(procedures_binary, by = "SUBJECT_ID_COMPOSE") %>%
  # Pivot the data to wide format, turning LABEL rows into columns
  pivot_wider(
    names_from = LABEL,         # Use LABEL as column names
    values_from = VALUE,        # Fill columns with VALUE (indicates performed or not)
    values_fn = list(LABEL = ~ unique(.)), # Ensure one unique value per cell
    values_fill = NA            # Fill missing with NA for now
  ) %>%
  select(-`NA`) %>%
  # Replace NA with 0, otherwise set 1 in EXTUBATION, INTUBATION, and CHEST_X_RAY
  mutate(
    CHEST_X_RAY = if_else((`CHEST X-RAY` == "NULL"), 0, 1),
    EXTUBATION = if_else((EXTUBATION == "NULL"), 0, 1),
    INTUBATION = if_else((INTUBATION == "NULL"), 0, 1)
  ) %>%
  select(-`CHEST X-RAY`, -SUBJECT_ID)

# Transform the data into long format for visualization
procedures_long <- procedures_binary_survival_outcome_flags %>%
  pivot_longer(
    cols = c(CHEST_X_RAY, EXTUBATION, INTUBATION),  # Procedures to include
    names_to = "Procedure",                        # Column for procedure names
    values_to = "Performed"                        # Binary flag (0 or 1)
  )

# Create a boxplot
ggplot(procedures_long, aes(x = factor(Performed), y = SURVIVAL, fill = Procedure)) +
  geom_boxplot(outlier.color = color_palette[5], outlier.shape = 16, outlier.size = 2) +
  facet_wrap(~ Procedure, scales = "free_x") +  # Separate plots for each procedure
  scale_fill_manual(values = sample(color_palette, size = length(unique(procedures_long$Procedure)))) +
  labs(
    title = "Survival (Days) Distribution by Procedure Performed",
    x = "Procedure Performed (0 = Not Performed, 1 = Performed)",
    y = "Survival (Days)",
    fill = "Procedure"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```

### 8.4.3. Outcome 3: Length of ICU Stay by Procedures Data
#### 8.3.3.1. Procedures with duration
``` {r Length of ICU Stay by Procedures Data Procedures with duration}
procedures_with_duration_los_outcome <- LOS_outcome %>%
  left_join(procedures_with_duration, by = "SUBJECT_ID_COMPOSE")
  
ggplot(procedures_with_duration_los_outcome, aes(x = LABEL, y = LOS, fill = LABEL)) +
  geom_boxplot(outlier.color = color_palette[8], outlier.size = 2, alpha = 0.6) +
  labs(
    title = "Distribution of LOS by Procedures with Duration",
    x = "Procedure",
    y = "LOS (Days)"
  ) +
  scale_fill_manual(values = sample(color_palette, size = length(unique(procedures_with_duration_los_outcome$LABEL)), replace = FALSE)) +
  theme_custom +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )
```

#### 8.3.3.2. Procedures without Duration
``` {r Length of ICU Stay by Procedures Data Procedures without duration}

procedures_binary_los_outcome_flags <- LOS_outcome %>%
  left_join(procedures_binary, by = "SUBJECT_ID_COMPOSE") %>%
  # Pivot the data to wide format, turning LABEL rows into columns
  pivot_wider(
    names_from = LABEL,         # Use LABEL as column names
    values_from = VALUE,        # Fill columns with VALUE (indicates performed or not)
    values_fn = list(LABEL = ~ unique(.)), # Ensure one unique value per cell
    values_fill = NA            # Fill missing with NA for now
  ) %>%
  select(-`NA`) %>%
  # Replace NA with 0, otherwise set 1 in EXTUBATION, INTUBATION, and CHEST_X_RAY
  mutate(
    CHEST_X_RAY = if_else((`CHEST X-RAY` == "NULL"), 0, 1),
    EXTUBATION = if_else((EXTUBATION == "NULL"), 0, 1),
    INTUBATION = if_else((INTUBATION == "NULL"), 0, 1)
  ) %>%
  select(-`CHEST X-RAY`, -SUBJECT_ID)

# Transform the data into long format for visualization
procedures_long <- procedures_binary_los_outcome_flags %>%
  pivot_longer(
    cols = c(CHEST_X_RAY, EXTUBATION, INTUBATION),  # Procedures to include
    names_to = "Procedure",                        # Column for procedure names
    values_to = "Performed"                        # Binary flag (0 or 1)
  )

# Create a boxplot
ggplot(procedures_long, aes(x = factor(Performed), y = LOS, fill = Procedure)) +
  geom_boxplot(outlier.color = color_palette[20], outlier.shape = 16, outlier.size = 2) +
  facet_wrap(~ Procedure, scales = "free_x") +  # Separate plots for each procedure
  scale_fill_manual(values = sample(color_palette, size = length(unique(procedures_long$Procedure)))) +
  labs(
    title = "LOS (Days) Distribution by Procedure Performed",
    x = "Procedure Performed (0 = Not Performed, 1 = Performed)",
    y = "LOS (Days)",
    fill = "Procedure"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

## 8.4. Exploratory analysis
### 8.4.1. Outcome 1: Death Status by Procedures Data

```{r Death Status by Procedures Data Exploratory Analysis}

# List of procedures to analyze
procedure_labels <- c("INVASIVE VENTILATION", "ARTERIAL LINE", "MULTI LUMEN", "DIALYSIS - CRRT")

# Perform statistical tests for each procedure
results_selected_procedures <- procedures_with_duration_death_outcome %>%
  filter(LABEL %in% procedure_labels) %>%  # Filter for specified procedures
  group_split(LABEL) %>%  # Split the data by LABEL
  map_df(~ {
    perform_statistical_tests(
      data = .x,
      dependent_var = "SURVIVAL_FLAG",
      independent_var = "VALUE",
      variable_name = unique(.x$LABEL)
    )
  })

# Check hypothesis for procedures without duration 
# List of procedures without duration
procedure_labels_binary <- c("CHEST_X_RAY", "EXTUBATION", "INTUBATION")

# Perform statistical tests for each procedure
results_procedures_without_duration <- procedures_binary_death_outcome_flags %>%
  pivot_longer(
    cols = all_of(procedure_labels_binary),  # Select relevant procedure columns
    names_to = "LABEL",                     # Create a new column for procedure names
    values_to = "Performed"                 # Binary flag: 0 or 1
  ) %>%
  group_split(LABEL) %>%  # Split the data by LABEL
  map_df(~ {
    perform_statistical_tests(
      data = .x,
      dependent_var = "SURVIVAL_FLAG",
      independent_var = "Performed",
      variable_name = unique(.x$LABEL)
    )
  })

# Print the results
print_table(bind_rows(results_procedures_without_duration,results_selected_procedures ))

# Clean up all intermediate results
rm(results_selected_procedures, results_procedures_without_duration)

```

All analyzed procedures, including CHEST_X_RAY, EXTUBATION, INTUBATION, ARTERIAL LINE, DIALYSIS – CRRT, INVASIVE VENTILATION, and MULTI LUMEN, showed significant associations with survival outcomes based on the Mann-Whitney U Test (p < 0.05). This suggests that these procedures potentially influence survival probability and may serve as valuable predictors in future survival modeling. Including these variables in future models could enhance the accuracy of survival predictions, especially in critical care contexts

### 8.4.2. Outcome 2: Length of Survival by Procedures

```{r Length of Survival by Procedures Exploratory analysis}

# Generate Kaplan-Meier survival curve by number of drugs
fit_procedures_X_RAY <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ CHEST_X_RAY, data = procedures_binary_survival_outcome_flags)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_procedures_X_RAY,
  data = procedures_binary_survival_outcome_flags,
  pval = TRUE,  # Display p-value for drug number
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "CHEST_X_RAY",
  title = "Survival Curve by CHEST_X_RAY",
  palette = color_palette
)

fit_procedures_EXTUBATION <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ EXTUBATION, data = procedures_binary_survival_outcome_flags)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_procedures_EXTUBATION,
  data = procedures_binary_survival_outcome_flags,
  pval = TRUE,  # Display p-value for drug number
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Extubation",
  title = "Survival Curve by Extubation",
  palette = color_palette
)

fit_procedures_INTUBATION <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ INTUBATION, data = procedures_binary_survival_outcome_flags)

# Plot the Kaplan-Meier curve
ggsurvplot(
  fit_procedures_INTUBATION,
  data = procedures_binary_survival_outcome_flags,
  pval = TRUE,  # Display p-value for drug number
  conf.int = TRUE,  # Add confidence intervals
  ggtheme = theme_custom,
  surv.median.line = "hv",
  legend.title = "Intubation",
  title = "Survival Curve by Intubation",
  palette = color_palette
)

# Perform Hazard Ratio (HR) assessment
hr_table_X_RAY <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", "CHEST_X_RAY", procedures_binary_survival_outcome_flags)

hr_table_EXTUBATION <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", "EXTUBATION", procedures_binary_survival_outcome_flags)

hr_table_INTUBATION <- HR_assessment("SURVIVAL", "SURVIVAL_FLAG", "INTUBATION", procedures_binary_survival_outcome_flags)

# Filter and analyze procedures with duration
km_results_procedures <- procedures_with_duration_survival_outcome %>%
  filter(LABEL %in% procedure_labels) %>%  # Filter for specific procedures
  group_split(LABEL) %>%  # Split the data by LABEL
  map(~ {
    # Handle cases with insufficient or constant values
    if (n_distinct(.x$VALUE, na.rm = TRUE) > 3) {
      .x <- .x %>%
        mutate(Quartile = cut(
          VALUE,
          breaks = quantile(.x$VALUE, probs = 0:4/4, na.rm = TRUE),
          include.lowest = TRUE,
          labels = c("Q1", "Q2", "Q3", "Q4")  # Label quartiles
        ))
      
      fit <- survfit(Surv(SURVIVAL, SURVIVAL_FLAG) ~ Quartile, data = .x)
      
      # Create the Kaplan-Meier plot
      ggsurvplot(
        fit,
        data = .x,
        pval = TRUE,
        conf.int = TRUE,
        title = paste("Kaplan-Meier Survival Curve for", unique(.x$LABEL)),
        legend.title = "Quartiles",
        xlab = "Survival (Days)",
        ylab = "Survival Probability",
        palette = color_palette
      )
    } else {
      message(paste("Skipping", unique(.x$LABEL), "due to insufficient unique values"))
      NULL
    }
  })

# Filter out NULL results (cases with insufficient unique values)
km_results_procedures <- km_results_procedures[!sapply(km_results_procedures, is.null)]

# Print all Kaplan-Meier plots
for (plot in km_results_procedures) {
  print(plot)
}

# Divide procedure durations into quintiles and perform HR assessment
hr_results_procedures_with_quintiles <- procedures_with_duration_survival_outcome %>%
  filter(LABEL %in% procedure_labels) %>%  # Filter for specified procedures
  group_split(LABEL) %>%  # Split the data by LABEL
  map_df(~ {
    # Add quintiles for VALUE (duration)
    .x <- .x %>%
      mutate(
        Quintile = cut(
          VALUE,
          breaks = quantile(VALUE, probs = seq(0, 1, 0.2), na.rm = TRUE),
          include.lowest = TRUE,
          paste(c("Q1", "Q2", "Q3", "Q4", "Q5"), unique(.x$LABEL), sep = " _ ")
        )
      )
    
    # Perform HR assessment using the Quintile variable
    HR_assessment(
      survival_time = "SURVIVAL",
      event_status = "SURVIVAL_FLAG",
      predictors = "Quintile",
      data = .x
    ) 
  })

# Print the combined HR results
print_table(bind_rows(hr_table_X_RAY, hr_table_EXTUBATION, hr_table_INTUBATION, hr_results_procedures_with_quintiles))

# Clean up Kaplan-Meier and Hazard Ratio variables
rm(fit_procedures_X_RAY, fit_procedures_EXTUBATION, fit_procedures_INTUBATION)
rm(hr_table_X_RAY, hr_table_EXTUBATION, hr_table_INTUBATION)
rm(km_results_procedures, hr_results_procedures_with_quintiles)

# Clean up lists of procedure labels
rm(procedure_labels, procedure_labels_binary)
```

All analyzed procedures should be included in predictive survival models, as their HRs provide valuable insights into patient severity and outcomes except DIALYSIS. Special attention should be given to procedures like INTUBATION and INVASIVE VENTILATION, which strongly correlate with higher risk, as they may serve as critical predictors of poor survival

### 8.4.3. Outcome 3: Length of ICU Stay by Procedures Data

``` {r Length of ICU Stay by Procedures Data Exploratory analysis }
# List of procedures without duration
procedure_labels_binary <- c("CHEST_X_RAY", "EXTUBATION", "INTUBATION")

results_procedures_without_duration_LOS <- procedures_binary_los_outcome_flags %>%
  pivot_longer(
    cols = all_of(procedure_labels_binary),  # Select relevant procedure columns
    names_to = "LABEL",                     # Create a new column for procedure names
    values_to = "Performed"                 # Binary flag: 0 or 1
  ) %>%
  group_split(LABEL) %>%  # Split the data by LABEL
  map_df(~ {
    # Extract the LABEL name for the current group
    label_name <- unique(.x$LABEL)
    
    # Perform LOS analysis
    analyze_predictor_LOS(
      data = .x,
      predictor = "Performed",
      LOS = "LOS",
      patient_id = "SUBJECT_ID_COMPOSE"
    ) %>%
    mutate(Procedure = label_name)  # Add the LABEL name to the results
  })

# List of procedures with duration
procedure_labels_duration <- c("INVASIVE VENTILATION", "ARTERIAL LINE", "MULTI LUMEN", "DIALYSIS - CRRT")

# Perform analysis for procedures with durations split by quintiles
results_procedures_with_duration_LOS <- procedures_with_duration_los_outcome %>%
  filter(LABEL %in% procedure_labels_duration) %>%  # Filter for specified procedures
  group_split(LABEL) %>%  # Split the data by LABEL
  map_df(~ {
    # Add quintiles for VALUE (duration)
    .x <- .x %>%
      mutate(
        Quintile = cut(
          VALUE,
          breaks = quantile(VALUE, probs = seq(0, 1, 0.2), na.rm = TRUE),
          include.lowest = TRUE,
          labels = c("Q1", "Q2", "Q3", "Q4", "Q5")
        )
      )
    
    # Perform LOS analysis using Quintile
    analyze_predictor_LOS(
      data = .x,
      predictor = "Quintile",
      LOS = "LOS",
      patient_id = "SUBJECT_ID_COMPOSE"
    )  %>%
    mutate(Procedure = unique(.x$LABEL))
  })

# Print the results
print_table(bind_rows(results_procedures_without_duration_LOS, results_procedures_with_duration_LOS))

# Cleanup for procedures with duration
rm(procedure_labels_duration, procedures_with_duration_los_outcome)

# Cleanup all intermediate results
rm(procedures, procedures_binary, procedures_binary_los_outcome_flags, procedures_long, results_procedures_without_duration_LOS, results_procedures_with_duration_LOS)
```

From the analysis of the mixed-effects linear model on the Length of Stay (LOS) outcome, the procedures "CHEST_X_RAY," "EXTUBATION," "INTUBATION," "ARTERIAL LINE," "INVASIVE VENTILATION," and "MULTI LUMEN" all showed statistically significant associations, with p-values less than 0.05. This suggests that these procedures could have an influence on LOS and may be valuable to include in future predictive models. 

On the other hand, "DIALYSIS - CRRT" showed predominantly non-significant results, indicating that it may not be a strong predictor of LOS in the context of this analysis. Therefore, it might be less critical for inclusion in future modeling efforts.

# 9.    Result Table

```{r result table}

# Create the data frame with consistent and clear values for merging
data <- data.frame(
  Predictor = c(
    "Demographic factors", "Gender", "Age", 
    
    "Socio-economic, and health system factors", "Admission type", "Marital Status", "Insurance", "Religion", "Ethnicity",
    
    "Diagnoses", "Number of diagnoses", "ICD9_486: Pneumonia", "ICD9_41071: Acute Myocardial Infarction", "ICD9_41401: Coronary Atherosclerosis", "ICD9_4240: Mitral Valve Disorders", "ICD9_4280: Congestive Heart Failure", "ICD9_5849: Acute Renal Failure", "ICD9_0389: Septicemia", "ICD9_4241: Aortic Valve Disorders", "ICD9_430: Subarachnoid Hemorrhage", "ICD9_431: Intracerebral Hemorrhage", "ICD9_51881: Acute Respiratory Failure", "ICD9_5070: Aspiration Pneumonitis", 
    
    "Isolations", "CDIFF", "MRSA", "VRE",
    
    "Prescriptions", "Number of prescriptions", "ATC codes", "J01CA: Penicillins with beta-lactamase inhibitors", "J01DD: Third-generation cephalosporins", "J01DH: Carbapenems", "J01GB: Aminoglycosides", "J02AC: Triazole antifungals", "B01AA: Vitamin K antagonists", "B01AB: Heparins", "B01AC: Platelet aggregation inhibitors", "C01AA: Digitalis glycosides", "C01CA: Beta-blocking agents", "C09AA: ACE inhibitors", "C09CA: Angiotensin II receptor blockers", "N02AA: Natural opium alkaloids", "N05CD: Benzodiazepine derivatives", "N01AH: Opioid analgesics", "L04AD: Selective immunosuppressants", "L01EG: Pyrimidine analogues", "R03AC: Selective beta-2-adrenoreceptor agonists", "R03DC: Leukotriene receptor antagonists", "H02AA: Glucocorticoids", "H01AA: Thyroid hormones", "B05BB: Solutions affecting the electrolyte balance", "B05XA: Blood substitutes and perfusion solutions", "A02BA: H2-receptor antagonists", "A02BC: Proton pump inhibitors", "D01AC: Antifungals for topical use",
    
    "Procedures", "Chest X RAY", "Extubation", "Intubation", "Arterial line", "Invasive ventilation", "Dialysis - CRRT",
    
    "Blood Gas (Last Values)", "Hemoglobin", "Base excess", "Free calcium", "Lactate", "PCO2", "PH", "PO2", "Potassium whole blood", "Sodium whole blood", "Chloride whole blood", "PEEP", "Temperature", "Oxygen", "Oxygen saturation", "Tidal volume", "Ventilation rate", "Caclulated bicarbonate whole blood", "Calculated Total CO2", "Alveolar arterial gradient", "O2 flow", "Methehemoglobin", "Carboxyhemoglobin",
    
    "Blood Gas (Mean Values)", "Hemoglobin", "Base excess", "Free calcium", "Lactate", "PCO2", "PH", "PO2", "Potassium whole blood", "Sodium whole blood", "Chloride whole blood", "PEEP", "Temperature", "Oxygen", "Oxygen saturation", "Tidal volume", "Ventilation rate", "Caclulated bicarbonate whole blood", "Calculated Total CO2", "Alveolar arterial gradient", "O2 flow", "Methehemoglobin", "Carboxyhemoglobin",
    
    "Hematology (Last Values)", "Hemoglobin", "RBC", "INR PT", "Lymphocytes", "MCH", "MCHC", "MCV", "Monocytes", "Neutrophils", "Eosinophils", "Platelet count", "PTT", "PT", "RDW", "WBC", "Fibrinogen functional", "Basophils", "Sedimentation rate", "Reticulocyte count", "D-dimer",
    
    "Hematology (Mean Values)", "Hemoglobin", "RBC", "INR PT", "Lymphocytes", "MCH", "MCHC", "MCV", "Monocytes", "Neutrophils", "Eosinophils", "Platelet count", "PTT", "PT", "RDW", "WBC", "Fibrinogen functional", "Basophils", "Sedimentation rate", "Reticulocyte count", "D-dimer",
    
    "Blood Chemistry (Last Values)", "Potassium", "Sodium", "Creatinine", "Chloride", "Urea nitrogen", "Bicarbonate", "Glucose", "Anion gap", "Magnesium", "Phosphate", "Calcium total", "Bilirubin total", "ALT", "AST", "CRP", "Trroponin T", "LD",
    
    "Blood Chemistry (Mean Values)", "Potassium", "Sodium", "Creatinine", "Chloride", "Urea nitrogen", "Bicarbonate", "Glucose", "Anion gap", "Magnesium", "Phosphate", "Calcium total", "Bilirubin total", "ALT", "AST", "CRP", "Trroponin T", "LD"),
  
  Death_Status = c("", "+", "+", 
                   
                   "", "+", "+", "+", "+", "+", 
                   
                   "", "+", "+", "-", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+", 
                   
                   "", "+", "+", "+",
                   
                   "", "+", "", "-", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+", "+", "+",
                   
                   "", "+", "+", "+", "+", "+", "+",
                   
                   "", "+", "+", "+", "+", "+", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-",
                   
                   "", "+", "+", "+", "+", "+", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-",
    
                  "", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-", "+",
                  
                  "", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-", "+",
                  
                  "", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+",
                  
                  "", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+" ),
  
  
  Survival = c("", "+↓", "+↑", 
               
               "", "+↑", "+↑↓", "+↑", "+", "+", 
               
               "", "-", "+↑", "-", "+↓", "+↓", "-", "+↑", "+↑", "+↓", "+↑", "+↑", "+↑", "+↑",
               
               "", "+↑", "-", "+↑",
               
               "", "+", "", "+↓", "-", "+↑", "-", "+↑", "+↓", "+↓", "+↓", "-", "+↑", "+↓", "+↓", "+↑", "+↑", "+↑", "-", "-", "+↓", "+↓", "+↑", "+↑", "-", "+↓", "+↓", "-", "+↓",
               
               "", "+", "+", "+", "+", "+", "-",
               
               "", "+↓", "+↓", "+↓", "+↑", "+↑", "+↓", "+↓", "+↑", "-", "-", "-", "+↓", "+↑", "+↓", "+↓", "+↑", "+↓", "+↓", "+↑", "+↑", "-", "-",
               
               "", "-", "+↓", "+↓", "+↑", "+↑", "+↓", "+↓", "+↑", "+↑", "-", "-", "+↓", "+↑", "+↓", "+↓", "+↑", "+↓", "+↓", "+↑", "+↑", "-", "-",
    
    "", "-", "-", "+↑", "+↓", "+↑", "+↓", "+↑", "+↓", "+↑", "+↓", "+↓", "+↑", "+↑", "+↑", "+↑", "-", "+↓", "-", "-", "+↑",
    
    "", "+↑", "+↑", "-", "+↓", "+↑", "+↓", "+↑", "+↓", "+↑", "+↓", "+↓", "+↑", "+↑", "+↑", "+↑", "-", "+↓", "-", "-", "+↑",
    
    "", "+↑", "+↑", "+↑", "-", "+↑", "+↓", "+↑", "+↑", "+↑", "+↑", "+↓", "+↑", "+↑", "+↑", "+↑", "+↑", "+↑",
    
    "", "+↑", "+↑", "+↑", "+↑", "+↑", "+↓", "+↑", "+↑", "+↑", "+↑", "+↓", "+↑", "+↑", "+↑", "+↑", "+↑", "+↑"),
  
  
  LOS = c("", "-", "+", 
          
          "", "+", "-", "+", "+", "-", 

          "", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "-", "+", "+", 
          
          "", "+", "+", "+",
          
          "", "+", "", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+",
          
          "", "+", "+", "+", "+", "+", "-",
          
          "", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-",
          
          "", "+", "+", "-", "+", "-", "+", "+", "+", "-", "+", "+", "+", "+", "-", "+", "+", "+", "+", "+", "+", "-", "+",
    
    "", "+", "+", "-", "+", "-", "+", "+", "-", "+", "+", "-", "+", "-", "+", "+", "+", "+", "+", "+", "-",
    
    "", "+", "+", "-", "+", "-", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+",
    
    "", "+", "+", "-", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "+",
    
    "", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "+"))


# Use the function to render the table
print_table(data, format = "html")

```

# 10. Prepare DataSet for Future Modeling

```{r Prepare DataSet for Future Modeling Death Outcome}
patients_death_status <- patients_death_status %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

diagnoses_transformed_death_outcome <- diagnoses_transformed_death_outcome %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

labs_blood_gas_death_outcome_last <- labs_blood_gas_death_outcome_last %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

labs_blood_gas_death_outcome_mean <- labs_blood_gas_death_outcome_mean %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

hematology_death_outcome_last <- hematology_death_outcome_last %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

hematology_death_outcome_mean <- hematology_death_outcome_mean %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

chemistry_death_outcome_last <- chemistry_death_outcome_last %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

chemistry_death_outcome_mean <- chemistry_death_outcome_mean %>%
  mutate(
    SURVIVAL_FLAG = as.numeric(SURVIVAL_FLAG)
  )

death_status <- admissions_death_outcome %>%
  left_join(patients_death_status, by = c("SUBJECT_ID", "SURVIVAL_FLAG"))

diagnoses_death_outcome <- diagnoses_death_outcome %>%
  select(-LONG_TITLE, -SEQ_NUM) %>%
  distinct()

death_status <- death_status %>%
  left_join(diagnoses_death_outcome, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG"))

death_status <- death_status %>%
  left_join(diagnoses_transformed_death_outcome, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG")) %>%
  # Replace all NAs with 0
  mutate(across(starts_with("ICD9"), ~ as.numeric(as.character(.)))) %>%  # Convert factors to numeric
  mutate(across(starts_with("ICD9"), ~ replace_na(., 0))) %>%  # Replace NA with 0
  mutate(across(starts_with("ICD9"), ~ as.factor(.)))
  
death_status <- death_status %>%
  left_join(prescriptions_number, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG"))

 # add ATC_ label before column names
prescriptions_transformed_death_outcome <- prescriptions_transformed_death_outcome %>%
  rename_with(~ paste0("ATC_", .x), -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG))

death_status <- death_status %>%
  # add ATC_ before column names
  left_join(prescriptions_transformed_death_outcome, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG")) %>%
  # All NA's change to 0 in columns from prescriptions_transformed_death_outcome
  mutate(across(starts_with("ATC"), ~ as.numeric(as.character(.)))) %>%  # Convert factors to numeric
  mutate(across(starts_with("ATC"), ~ replace_na(., 0))) %>%  # Replace NA with 0
  mutate(across(starts_with("ATC"), ~ as.factor(.)))

death_status <- death_status %>%
  left_join(isolations_death_outcome, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG")) %>%
  # All NA's change to 0 
  mutate(across(starts_with("REQUEST"), ~ as.numeric(as.character(.)))) %>%  # Convert factors to numeric
  mutate(across(starts_with("REQUEST"), ~ replace_na(., 0))) %>%  # Replace NA with 0
  mutate(across(starts_with("REQUEST"), ~ as.factor(.)))
  

# Add to each column except SUBJECT_ID_COMPOSE and SURVIVAL_FLAG prefix LAST_
labs_blood_gas_death_outcome_last <- labs_blood_gas_death_outcome_last %>%
  rename_with(~ paste0("LAST_", .x), -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG))

death_status <- death_status %>%
  left_join(labs_blood_gas_death_outcome_last, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG"))

# Add to each column except SUBJECT_ID_COMPOSE and SURVIVAL_FLAG prefix MEAN_
labs_blood_gas_death_outcome_mean <- labs_blood_gas_death_outcome_mean %>%
  rename_with(~ paste0("MEAN_", .x), -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG))

death_status <- death_status %>%
  left_join(labs_blood_gas_death_outcome_mean, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG"))

# Add to each column except SUBJECT_ID_COMPOSE and SURVIVAL_FLAG prefix LAST_
hematology_death_outcome_last <- hematology_death_outcome_last %>%
  rename_with(~ paste0("LAST_", .x), -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG))

death_status <- death_status %>%
  left_join(hematology_death_outcome_last, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG"))

# Add to each column except SUBJECT_ID_COMPOSE and SURVIVAL_FLAG prefix MEAN_
hematology_death_outcome_mean <- hematology_death_outcome_mean %>%
  rename_with(~ paste0("MEAN_", .x), -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG))

death_status <- death_status %>%
  left_join(hematology_death_outcome_mean, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG"))

# Add to each column except SUBJECT_ID_COMPOSE and SURVIVAL_FLAG prefix LAST_
chemistry_death_outcome_last <- chemistry_death_outcome_last %>%
  rename_with(~ paste0("LAST_", .x), -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG)) 

death_status <- death_status %>%
  left_join(chemistry_death_outcome_last, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG")) %>%
  # All NA's change to 0 in columns from prescriptions_transformed_death_outcome
  mutate(across(starts_with("LAST"), ~ as.numeric(as.character(.)))) %>%  # Convert factors to numeric
  mutate(across(starts_with("LAST"), ~ replace_na(., 0))) %>%  # Replace NA with 0
  mutate(across(starts_with("LAST"), ~ as.factor(.)))

# Add to each column except SUBJECT_ID_COMPOSE and SURVIVAL_FLAG prefix MEAN_
chemistry_death_outcome_mean <- chemistry_death_outcome_mean %>%
  rename_with(~ paste0("MEAN_", .x), -c(SUBJECT_ID_COMPOSE, SURVIVAL_FLAG))

death_status <- death_status %>%
  left_join(chemistry_death_outcome_mean, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG")) %>%
  # All NA's change to 0 in columns from prescriptions_transformed_death_outcome
  mutate(across(starts_with("MEAN"), ~ as.numeric(as.character(.)))) %>%  # Convert factors to numeric
  mutate(across(starts_with("MEAN"), ~ replace_na(., 0))) %>%  # Replace NA with 0
  mutate(across(starts_with("MEAN"), ~ as.factor(.)))

procedures_with_duration_death_outcome_long <- procedures_with_duration_death_outcome %>%
  pivot_wider(
    names_from = LABEL,   # Column to turn into new column names
    values_from = VALUE   # Column to populate the new columns
  )

death_status <- death_status %>%
  left_join(procedures_with_duration_death_outcome_long, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG"))

procedures_binary_death_outcome_flags <- procedures_binary_death_outcome_flags %>%
  select(-SUBJECT_ID)

death_status <- death_status %>%
  left_join(procedures_binary_death_outcome_flags, by = c("SUBJECT_ID_COMPOSE", "SURVIVAL_FLAG")) %>%
  mutate(across(c("EXTUBATION", "INTUBATION", "CHEST_X_RAY"), ~ as.numeric(as.character(.)))) %>%  # Convert factors to numeric
  mutate(across(c("EXTUBATION", "INTUBATION", "CHEST_X_RAY"), ~ replace_na(., 0))) %>%  # Replace NA with 0
  mutate(across(c("EXTUBATION", "INTUBATION", "CHEST_X_RAY"), ~ as.factor(.)))  # Convert back to factors

# Save to CSV to directory prepared_to_prediction
write_csv(death_status, "../data/prepared_to_prediction/Death_status.csv")

```

